<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MINT</title>
  
  <subtitle>感谢平庸与我随行!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.dookt.com/"/>
  <updated>2019-08-13T17:08:17.038Z</updated>
  <id>http://www.dookt.com/</id>
  
  <author>
    <name>Mr.Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker学习</title>
    <link href="http://www.dookt.com/post/6782be63.html"/>
    <id>http://www.dookt.com/post/6782be63.html</id>
    <published>2019-08-13T11:49:12.000Z</published>
    <updated>2019-08-13T17:08:17.038Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是Docker项目开发的一种容器格式。docker命令可以运行、停止、启动、检查容器。</p><h4 id="Docker-Hub-Registry"><a href="#Docker-Hub-Registry" class="headerlink" title="Docker Hub Registry"></a>Docker Hub Registry</h4><p>提供了个人与组织保存和开发Docker容器镜像的地方</p><h4 id="Docker镜像和容器"><a href="#Docker镜像和容器" class="headerlink" title="Docker镜像和容器"></a>Docker镜像和容器</h4><p>容器化的目的是将应用程序运行所需要的所有组件集合在一个单一而独立的单元中。对于Docker来说，这个单元被称为镜像。</p><p>镜像：是一个静态单元，它是容器运行的应用程序以及应用程序执行所需要的库、配置文件、可执行程序或者其他组件。</p><p>容器：指的是一个已运行的Docker镜像的实例。</p><h4 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h4><ul><li>查找Docker组件的信息<ul><li>docker version：查看docker版本</li><li>docker info：查看docker系统信息</li><li>docker help：查看与docker命令一起使用的命令或选项</li><li>docker history：查看镜像历史</li><li>docker inspect：查看镜像或者容器信息</li><li>docker port：列出容器的端口映射</li></ul></li><li>操作正在运行的容器<ul><li>docker ps：列出正在运行的容器</li><li>docker attach：将另一个命令附加到正在运行的容器上</li><li>docker exec：在正在运行的容器中执行命令</li><li>docker inspect：审查容器的元数据</li><li>docker cp：从容器中复制文件到宿主机</li><li>docker diff：检查容器从启动后其文件系统所做的改变</li></ul></li><li>操作镜像<ul><li>docker images：查看系统上的镜像</li><li>docker run：运行镜像</li><li>docker pull：从registry上拉取镜像</li><li>docker push：将镜像传到registry中</li><li>docker save：将镜像保存为tarball</li><li>docker load：将tarball加载到本地镜像</li><li>docker export：从容器中将文件系统导出成本地文件系统的tarball文件</li></ul></li><li>操作Docker Registry<ul><li>docker search：在registry中搜索镜像</li><li>docker login：登陆到Docker Hub Registry（可以通过自己的账号推送拉取镜像）</li><li>docker logout：从Docker Hub Registry中登出</li></ul></li><li>修改现存的镜像<ul><li>docker tag：未镜像添加一个名字</li><li>docker rename：修改镜像名字</li></ul></li><li>修改容器的状态<ul><li>docker stop：停止正在运行的容器</li><li>docker start：启动已经停止的容器</li><li>docker restart：重启启动容器</li><li>docker pause：暂停正在运行的容器</li><li>docker unpause：重新启动已经暂停的容器</li><li>docker kill：向容器发送kill信号或其他信号</li></ul></li><li>查看Docker的活动<ul><li>docker events：查看Docker服务器的事件</li><li>docker top：查看容器的进程</li><li>docker logs：查看容器产生的日志消息</li><li>docker stats：查看容器的CPU和内存使用统计</li><li>docker wait：查看容器直到它停止</li></ul></li><li>创建镜像和容器：<ul><li>docker build：从头构建镜像</li><li>docker commit：从容器创建镜像</li><li>docker create：从镜像创建容器但是不运行它</li><li>docker import：将文件系统导入镜像中</li></ul></li></ul><h3 id="部署搭建Docker运行环境"><a href="#部署搭建Docker运行环境" class="headerlink" title="部署搭建Docker运行环境"></a>部署搭建Docker运行环境</h3><h4 id="在Centos7系统中安装docker"><a href="#在Centos7系统中安装docker" class="headerlink" title="在Centos7系统中安装docker"></a>在Centos7系统中安装docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ sudo yum -y install epel-release</span><br><span class="line">[mint@ali-mint ~]$ sudo yum -y install docker</span><br><span class="line">[mint@ali-mint ~]$ systemctl restart docker</span><br><span class="line">[mint@ali-mint ~]$ systemctl enabled docker</span><br><span class="line">[mint@ali-mint ~]$ systemctl status docker</span><br><span class="line">[mint@ali-mint ~]$ docker version</span><br></pre></td></tr></table></figure><h4 id="在ubuntu系统安装docker"><a href="#在ubuntu系统安装docker" class="headerlink" title="在ubuntu系统安装docker"></a>在ubuntu系统安装docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ sudo apt -y update</span><br><span class="line">[mint@ali-mint ~]$ sudo apt -y install docker.io</span><br><span class="line">[mint@ali-mint ~]$ sudo service docker.io restart</span><br><span class="line">[mint@ali-mint ~]$ sduo service docker.io status</span><br><span class="line">[mint@ali-mint ~]$ sudo dpkg-qurey -L docker.io | less</span><br></pre></td></tr></table></figure><h3 id="搭建Docker-Registry"><a href="#搭建Docker-Registry" class="headerlink" title="搭建Docker Registry"></a>搭建Docker Registry</h3><h3 id="运行容器镜像"><a href="#运行容器镜像" class="headerlink" title="运行容器镜像"></a>运行容器镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run centos cat /etc/os-release</span><br><span class="line">NAME="CentOS Linux"</span><br><span class="line">VERSION="7 (Core)"</span><br><span class="line">ID="centos"</span><br><span class="line">ID_LIKE="rhel fedora"</span><br><span class="line">VERSION_ID="7"</span><br><span class="line">PRETTY_NAME="CentOS Linux 7 (Core)"</span><br><span class="line">ANSI_COLOR="0;31"</span><br><span class="line">CPE_NAME="cpe:/o:centos:centos:7"</span><br><span class="line">HOME_URL="https://www.centos.org/"</span><br><span class="line">BUG_REPORT_URL="https://bugs.centos.org/"</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT="CentOS-7"</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION="7"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT="centos"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION="7"</span><br></pre></td></tr></table></figure><p>执行以上docker run centos cat /etc/os-release命令则docker引擎会进行以下操作 </p><ul><li>寻找镜像: 到centos:latest的镜像，本地仓库没有则会到Docker.io的registry查找，并下载centos:lateset</li><li>执行命令: cat命令会显示出/etc/os-release文件的内容</li></ul><p>以上命令执行只是打印/etc/os-release文件的内容，打印完就执行完了。可以使用docker images查看本地系统的镜像，docker ps查看正在运行的容器，docker ps -a查看所有容器，如果需要重新启动该容器，则需要使用docker start命令启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">fedora              latest              ef49352c9c21        11 days ago         246MB</span><br><span class="line">ubuntu              latest              3556258649b2        2 weeks ago         64.2MB</span><br><span class="line">centos              latest              9f38484d220f        5 months ago        202MB</span><br><span class="line">[mint@ali-mint ~]$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">12572b653b36        centos              "cat /etc/os-release"   16 minutes ago      Exited (0) 16 minutes ago                       upbeat_noyce</span><br><span class="line">[mint@ali-mint ~]$ docker start -i 12572b653b36</span><br><span class="line">NAME="CentOS Linux"</span><br><span class="line">VERSION="7 (Core)"</span><br><span class="line">ID="centos"</span><br><span class="line">ID_LIKE="rhel fedora"</span><br><span class="line">VERSION_ID="7"</span><br><span class="line">PRETTY_NAME="CentOS Linux 7 (Core)"</span><br><span class="line">ANSI_COLOR="0;31"</span><br><span class="line">CPE_NAME="cpe:/o:centos:centos:7"</span><br><span class="line">HOME_URL="https://www.centos.org/"</span><br><span class="line">BUG_REPORT_URL="https://bugs.centos.org/"</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT="CentOS-7"</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION="7"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT="centos"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION="7"</span><br></pre></td></tr></table></figure><p>此时使用docker start -i 12572b653b36，-i 选项把容器的输出定向到本地shell中</p><h4 id="以交互式运行容器镜像"><a href="#以交互式运行容器镜像" class="headerlink" title="以交互式运行容器镜像"></a>以交互式运行容器镜像</h4><p>常见的例子，打开一个shell在容器内部直接进行操作。可以方便查看容器内部情况并修改内容。以下我通过执行/bin/bash命令打开一个容器的shell进行交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it centos /bin/bash</span><br><span class="line">[root@10962ad1fb5c /]#</span><br><span class="line">[root@10962ad1fb5c /]# ps -e</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 bash</span><br><span class="line">   14 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><p>此时已经来到容器内部了，可以通过主机名来看，如果主机名没有变化，可以通过执行ps -e命令来查看正在运行的命令来判断。</p><p>也可以在容器中执行命令，使用yum命令添加更多程序到容器中。可以使用exit退出容器shell，还可以通过docker commit命令制作新的镜像，需要使用docker ps -a查询到该容器的容器ID,本地系统就有一个名为testrun的镜像了并可以为接下来的docker run做准备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@10962ad1fb5c /]# yum -y install httpd vsftpd httpd-manual net-tools iproute</span><br><span class="line">[root@10962ad1fb5c /] exit</span><br><span class="line">[mint@ali-mint ~]$ docker commit 10962ad1fb5c testrun</span><br><span class="line">sha256:b38aa80475139935155a341257cb03f4b7cf6279f2a93b509d6a8daab60b8578z</span><br><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">testrun             latest              b38aa8047513        About a minute ago   356MB</span><br></pre></td></tr></table></figure><h4 id="在容器内运行管理命令"><a href="#在容器内运行管理命令" class="headerlink" title="在容器内运行管理命令"></a>在容器内运行管理命令</h4><p>想在运行容器之后结束后，容器自动销毁，可以添加–rm选项。这样就不会有太多无用容器占用磁盘空间。执行ip和route命令依赖于之前安装的net-tools和iproute命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it --rm testrun /usr/sbin/ip addr show eth0</span><br><span class="line">266: eth0@if267: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[mint@ali-mint ~]$ docker run -it --rm testrun /usr/sbin/route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.18.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line">[mint@ali-mint ~]$ ip addr show docker0</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:29:b8:4b:2f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>前两个docker命令查询到容器内的网络情况，接下来的IP命令显示了宿主机的docker0网络接口，它的一个IP地址172.18.0.1/16。默认情况下，宿主机会在容器启动时通过DHCP给容器分配地址。testrun运行的第一个ip地址为172.18.0.2/16。如果再次运行容器将会生成新的地址。因为通过run命令每次会生成新的容器。</p><p>通过route可以看到容器的默认网关是172.18.0.1，刚好是宿主机docker0网络接口的IP地址。通过宿主机的docker0接口进行路由能够让容器访问本地宿主机之外的网络资源</p><h4 id="运行容器化服务"><a href="#运行容器化服务" class="headerlink" title="运行容器化服务"></a>运行容器化服务</h4><p>使用容器运行服务由以下优势：</p><ul><li>配置：能够提前配置好所需的全部可执行程序，库，配置文件等无需担心宿主机是否提供这些组件，还方便将容器迁移至另一台服务器</li><li>隔离：每个容器都有自己的文件系统和网络接口，所以能够运行多个相同的服务容器</li></ul><p>使用docker简单构件apache web服务器，apache会默认监听80和443端口。首先创建宿主机目录，添加index.html文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ mkdir /var/www/html/</span><br><span class="line">[mint@ali-mint ~]$ cat  /var/www/html/index.html                                 </span><br><span class="line">The Apache Web Server is Running!</span><br></pre></td></tr></table></figure><p>使用之前构建的testrun镜像，执行以下命令前确保宿主机的80和443没有被占用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 80:80 -p 443:443 --name=MyWebServer -v /var/www/:/var/www/ testrun /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">da04638d9afc285111bd0eb51c4e73b0651c3e73ab14af997fb9f31e46cd6fe0</span><br></pre></td></tr></table></figure><table><thead><tr><th>选线</th><th>描述</th></tr></thead><tbody><tr><td>-d</td><td>让容器化命令在后台运行容器</td></tr><tr><td>-p 80:80 -p 443:443</td><td>映射端口，将容器端口映射到宿主机的端口上，冒号左边是宿主机端口，右边是容器端口。这里是将容器的80和443端口分别映射到宿主机的80和443端口上</td></tr><tr><td>–name=MyWebServer</td><td>指定容器名，之后可以通过容器名来操作容器，而不用通过难记的容器ID操作</td></tr><tr><td>-v /var/www:/var/www</td><td>挂载卷，将宿主机（冒号左边）的目录挂载到容器（冒号右边）的目录</td></tr><tr><td>testrun</td><td>镜像名称</td></tr><tr><td>/usr/sbin/httpd -DFOREGROUND</td><td>使用-DFOREGROUND选项来运行httpd守护进程</td></tr></tbody></table><p>此时使用docker ps可以看到该容器，看到容器被分配了容器ID，使用的镜像testrun，运行的命令是httpd，容器是在11分钟之前创建的，宿主机上所有IPv4的网络接口将会对80和443端口的请求转发到容器内对应的端口上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES</span><br><span class="line">da04638d9afc        testrun             "/usr/sbin/httpd -DF…"   11 minutes ago      Up 11 minutes       0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   MyWebServer</span><br></pre></td></tr></table></figure><p>也可以使用docker exec进入容器，按exit退出容器。</p><p>因为容器的80端口已经映射到宿主机的80上，所以通过访问宿主机的80端口即可访问到文件/var/www/html/index.html的内容。因为安装过httpd-manual包。所以还可以通过浏览器访问宿主机地址的80端口下的/manual页面可以访问到httpd的manual页</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker exec -it MyWebServer /bin/bash </span><br><span class="line">[root@da04638d9afc /]# exit</span><br><span class="line">exit</span><br><span class="line">[mint@ali-mint ~]$ curl localhost</span><br><span class="line">The Apache Web Server is Running!</span><br></pre></td></tr></table></figure><h4 id="在容器中运行服务时进行资源限制"><a href="#在容器中运行服务时进行资源限制" class="headerlink" title="在容器中运行服务时进行资源限制"></a>在容器中运行服务时进行资源限制</h4><p>默认情况下，容器运行时，容器访问内存、CPU方面是没有限制的，可以使用–memory、–momory-swap、–cpu-shares和–cpuset-cpus选项来限制可以使用的内存和CPU。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 80:80 -p 443:443 --name=MyWebServer -v /var/www/:/var/www/ --memory=10m --memory-swap=-1 --cpu-shares=256 testrun /usr/sbin/httpd -DFOREGROUND ec5e1a8281f0f8406187431f1eb3a5b46e864ab85adf2aadc8c5eddc1698a8fb</span><br></pre></td></tr></table></figure><ul><li>–memory=10m：容器可以使用10m的内存</li><li>–memory-swap=-1：容器可以无限制使用交换空间，如果不设置默认为memory的2倍（20m）</li><li>–cpu-shares=256： 在1024范围内设置CPU配额。设置256只占1024的25%</li><li>–cpuset-cpus=0,1：使用CPU核0或1</li><li>–cpuset-cpus=3：使用第四个CPU核</li><li>–cpuset-cpus=1-3：使用CPU核1，2或3</li></ul><h4 id="运行特权容器"><a href="#运行特权容器" class="headerlink" title="运行特权容器"></a>运行特权容器</h4><p>大多数情况下，运行docker容器时，会限制访问宿主机或其他容器的访问以及其他容器访问我正在运行的容器。然而有些特殊情况下，想要让容器拥有更大的宿主机系统访问权限。这种容器就成为特权容器</p><table><thead><tr><th>选线</th><th>描述</th></tr></thead><tbody><tr><td>–ipc</td><td>IPC：开放访宿主机的进程间通信设施。默认情况下，每个容器都有私有的IPC功能设施</td></tr><tr><td>–net-host</td><td>网络接口：向容器开放宿主机的网路接口。容器默认都有自己的网络接口</td></tr><tr><td>–pid=host</td><td>进程表：允许容器访问进程表。容器默认有自己的进程表</td></tr><tr><td>-e HOST=/host</td><td>宿主机文件系统：如果设置了，HOST环境变量会告诉容器将宿主机的root文件系统挂载到容器的某个目录上，推荐挂载在/host下</td></tr><tr><td>–privileged</td><td>这一选项会关闭容器运行命令的安全隔离。因此，以root运行的进程拥有宿主机上以root运行任何进程是同样的权限</td></tr></tbody></table><h3 id="查找、拉取、保存和装载容器镜像"><a href="#查找、拉取、保存和装载容器镜像" class="headerlink" title="查找、拉取、保存和装载容器镜像"></a>查找、拉取、保存和装载容器镜像</h3><h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><p>使用docker search命令搜索镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker search centos</span><br><span class="line">[mint@ali-mint ~]$ docker search ubuntu</span><br><span class="line">[mint@ali-mint ~]$ docker search nginx</span><br><span class="line">[mint@ali-mint ~]$ docker search mysql</span><br><span class="line">[mint@ali-mint ~]$ docker search jenkins</span><br></pre></td></tr></table></figure><p>也可以细化搜索</p><ul><li>-s：查找star数至少是多少的</li><li>–no-trunc：告诉docker search不要截取描述字段</li><li>automated=true：只显示定期自动重新构建的镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker search -s 100 centos</span><br><span class="line">[mint@ali-mint ~]$ docker search --no-trunc=true mysql</span><br><span class="line">[mint@ali-mint ~]$ docker search --automated=true centos</span><br></pre></td></tr></table></figure><h4 id="在Docker-Hub上检索镜像"><a href="#在Docker-Hub上检索镜像" class="headerlink" title="在Docker Hub上检索镜像"></a>在Docker Hub上检索镜像</h4><p>通过web浏览器访问<a href="https://registry.hub.docker.com/" target="_blank" rel="noopener">Docker Hub Registry</a>，可以找到镜像的很多信息。如果需要查找多个镜像的文档，可以访问<a href="https://github.com/docker-library/doc" target="_blank" rel="noopener">Docker Library</a>，找到相应镜像并查看其文档</p><ul><li>支持的镜像版本</li><li>用来运行镜像的基本docke run命令</li><li>配合docker run使用环境变量，这些变量可以更改镜像设置</li><li>这个容器镜像在github页面的位置</li><li>用于构建该镜像的Dockerfile文件</li></ul><h4 id="从Docker-Registry上拉取镜像"><a href="#从Docker-Registry上拉取镜像" class="headerlink" title="从Docker Registry上拉取镜像"></a>从Docker Registry上拉取镜像</h4><p>通过docker pull命令可以从docker registry上拉取镜像，可以从Docker Hub Registry上拉取，也可以从自建的docker registry上拉取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker pull centos</span><br><span class="line">[mint@ali-mint ~]$ docker pull mysql</span><br><span class="line">[mint@ali-mint ~]$ docker pull nginx</span><br><span class="line">[mint@ali-mint ~]$ docker pull 172.16.100.10:5000/centos</span><br><span class="line">[mint@ali-mint ~]$ docker pull 172.16.100.10:5000/mysql</span><br><span class="line">[mint@ali-mint ~]$ docker pull 172.16.100.10:5000/nginx</span><br></pre></td></tr></table></figure><h4 id="保存和装载镜像"><a href="#保存和装载镜像" class="headerlink" title="保存和装载镜像"></a>保存和装载镜像</h4><p>拉取镜像并不是将镜像放入Docker的唯一方式，还可以把镜像保存为tarball，然后copy到其他系统中，并装载它。</p><p>以下使用docker save命令将centos进行保存为一个tarball。tarball文件都包含了要构成保存镜像所需要的层，再将tar拷贝到另一个运行Docker服务的系统后，可使用docker load命令装载它并查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker save -o centos7.tar centos</span><br><span class="line">[mint@ali-mint ~]$ scp centos7.tar 172.18.9.50:/tmp</span><br><span class="line">[test@test ~]$ docker load -i /tmp/centos7.tar</span><br><span class="line">[test@test ~]$ docker images|grep centos</span><br></pre></td></tr></table></figure><h3 id="为镜像做标签"><a href="#为镜像做标签" class="headerlink" title="为镜像做标签"></a>为镜像做标签</h3><h3 id="分析容器"><a href="#分析容器" class="headerlink" title="分析容器"></a>分析容器</h3><p>每个镜像所附带的信息包含了默认配置、创建者信息以及何时以何种方式创建的细节。在容器运行后，容器会包含额外的信息，如容器的网络配置、容器是否正在运行以及挂载卷的信息。</p><p>在容器或镜像上运行docker inspect命令可以查看与之关联的底层数据。在用镜像或容器调试问题时，很有帮助。例如查看容器IP地址可以了解客户端程序（Web浏览器）去哪里寻找容器中运行的服务。docker inspect采用json格式显示，方便阅读。</p><h4 id="用docker-inspect检视基础镜像"><a href="#用docker-inspect检视基础镜像" class="headerlink" title="用docker inspect检视基础镜像"></a>用docker inspect检视基础镜像</h4><p>通过检视镜像可以大致了解到镜像的创建时间、构建镜像使用的Docker版本，对外开放的端口等信息。以下例子检视了最新的centos镜像。倘若centos:latest尚未拉取到我的本地系统，该命令会先拉取对应镜像并检视它。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect centos</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"sha256:9f38484d220fa527b1fb19747638497179500a1bed8bf0498eb788229229e6e1"</span>,</span><br><span class="line">        <span class="attr">"RepoTags"</span>: [</span><br><span class="line">            <span class="string">"centos:latest"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"RepoDigests"</span>: [</span><br><span class="line">            <span class="string">"centos@sha256:a799dd8a2ded4a83484bbae769d97655392b3f86533ceb7dd96bbac929809f3c"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"Parent"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"Comment"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"Created"</span>: <span class="string">"2019-03-14T21:19:53.361167852Z"</span>,</span><br><span class="line">        <span class="attr">"Container"</span>: <span class="string">"958baf5225f586da9c70a21e911a0a875402dd22d83133d78b3b3aa6130e7892"</span>,</span><br><span class="line">        <span class="attr">"ContainerConfig"</span>: &#123;</span><br><span class="line">            <span class="attr">"Hostname"</span>: <span class="string">"958baf5225f5"</span>,</span><br><span class="line">            <span class="attr">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"Env"</span>: [</span><br><span class="line">                <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"Cmd"</span>: [</span><br><span class="line">                <span class="string">"/bin/sh"</span>,</span><br><span class="line">                <span class="string">"-c"</span>,</span><br><span class="line">                <span class="string">"#(nop) "</span>,</span><br><span class="line">                <span class="string">"CMD [\"/bin/bash\"]"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"ArgsEscaped"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"Image"</span>: <span class="string">"sha256:294e8d8145287e70f07328cc09d840fad8980b801223321b983442f097aff0d8"</span>,</span><br><span class="line">            <span class="attr">"Volumes"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"Entrypoint"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"OnBuild"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"Labels"</span>: &#123;</span><br><span class="line">                <span class="attr">"org.label-schema.build-date"</span>: <span class="string">"20190305"</span>,</span><br><span class="line">                <span class="attr">"org.label-schema.license"</span>: <span class="string">"GPLv2"</span>,</span><br><span class="line">                <span class="attr">"org.label-schema.name"</span>: <span class="string">"CentOS Base Image"</span>,</span><br><span class="line">                <span class="attr">"org.label-schema.schema-version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">                <span class="attr">"org.label-schema.vendor"</span>: <span class="string">"CentOS"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"DockerVersion"</span>: <span class="string">"18.06.1-ce"</span>,</span><br><span class="line">        <span class="attr">"Author"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"Config"</span>: &#123;</span><br><span class="line">            <span class="attr">"Hostname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"Env"</span>: [</span><br><span class="line">                <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"Cmd"</span>: [</span><br><span class="line">                <span class="string">"/bin/bash"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"ArgsEscaped"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"Image"</span>: <span class="string">"sha256:294e8d8145287e70f07328cc09d840fad8980b801223321b983442f097aff0d8"</span>,</span><br><span class="line">            <span class="attr">"Volumes"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"Entrypoint"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"OnBuild"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"Labels"</span>: &#123;</span><br><span class="line">                <span class="attr">"org.label-schema.build-date"</span>: <span class="string">"20190305"</span>,</span><br><span class="line">                <span class="attr">"org.label-schema.license"</span>: <span class="string">"GPLv2"</span>,</span><br><span class="line">                <span class="attr">"org.label-schema.name"</span>: <span class="string">"CentOS Base Image"</span>,</span><br><span class="line">                <span class="attr">"org.label-schema.schema-version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">                <span class="attr">"org.label-schema.vendor"</span>: <span class="string">"CentOS"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">        <span class="attr">"Os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">        <span class="attr">"Size"</span>: <span class="number">201782942</span>,</span><br><span class="line">        <span class="attr">"VirtualSize"</span>: <span class="number">201782942</span>,</span><br><span class="line">        <span class="attr">"GraphDriver"</span>: &#123;</span><br><span class="line">            <span class="attr">"Data"</span>: &#123;</span><br><span class="line">                <span class="attr">"MergedDir"</span>: <span class="string">"/var/lib/docker/overlay2/dd869486238678b7bcbb999984ed8bfacb66603d9172b622d5dc18128ef81a19/merged"</span>,</span><br><span class="line">                <span class="attr">"UpperDir"</span>: <span class="string">"/var/lib/docker/overlay2/dd869486238678b7bcbb999984ed8bfacb66603d9172b622d5dc18128ef81a19/diff"</span>,</span><br><span class="line">                <span class="attr">"WorkDir"</span>: <span class="string">"/var/lib/docker/overlay2/dd869486238678b7bcbb999984ed8bfacb66603d9172b622d5dc18128ef81a19/work"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"Name"</span>: <span class="string">"overlay2"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"RootFS"</span>: &#123;</span><br><span class="line">            <span class="attr">"Type"</span>: <span class="string">"layers"</span>,</span><br><span class="line">            <span class="attr">"Layers"</span>: [</span><br><span class="line">                <span class="string">"sha256:d69483a6face4499acb974449d1303591fcbb5cdce5420f36f8a6607bda11854"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Metadata"</span>: &#123;</span><br><span class="line">            <span class="attr">"LastTagTime"</span>: <span class="string">"0001-01-01T00:00:00Z"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>从这些输出可以看出很多信息。该容器体系结构是amd64的，兼容64PC机。该镜像创建时没有定义Comment和Author。Config部分设置了容器运行的环境。</p><p>如果运行时没有指定其他命令，默认会运行/bin/bash命令。由于与标准输入、标准输出和标准错误的关联被设置为false。因此在运行该容器时要指定一些选项（docker run -it centos）。Env设置了PATH变量，定义了运行命令是用于查找命令的目录。</p><h4 id="查看镜像历史"><a href="#查看镜像历史" class="headerlink" title="查看镜像历史"></a>查看镜像历史</h4><p>可以在基础镜像是上构建生成新镜像。每次在镜像上运行新命令。就会长生一个新的容器层。如果这些层与镜像保存在一起就可以使用docker history命令查看这些信息。</p><p>要查看镜像历史，只要该镜像上执行docker history命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker history centos</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">9f38484d220f        5 months ago        /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B                  </span><br><span class="line">&lt;missing&gt;           5 months ago        /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B                  </span><br><span class="line">&lt;missing&gt;           5 months ago        /bin/sh -c #(nop) ADD file:074f2c974463ab38c…   202MB</span><br></pre></td></tr></table></figure><p>可以看到，镜像是5个月前构建的，并修改了3次，还可以看到生成镜像的shell命令。之后容器如果使用了IMAGE列的任何镜像层，就不必在拉去那个层，而只要使用系统中已经存在的这个层就可以了。</p><h4 id="检视正在运行的容器"><a href="#检视正在运行的容器" class="headerlink" title="检视正在运行的容器"></a>检视正在运行的容器</h4><p>以下例子使用centos镜像通过python命令和SimpleHTTPServer组件运行一个简单的Web服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker是Docker项目开发的一种容器格式。docker命令可以运行、停止、启动、检查容器。&lt;/p&gt;
&lt;h4 id=&quot;Docker-Hub-Registry&quot;&gt;&lt;a href=&quot;#Docker-Hub-Registry&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Docker" scheme="http://www.dookt.com/categories/Docker/"/>
    
    
      <category term="容器" scheme="http://www.dookt.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Centos安装vmware虚拟机报错</title>
    <link href="http://www.dookt.com/post/a583c2ce.html"/>
    <id>http://www.dookt.com/post/a583c2ce.html</id>
    <published>2019-08-04T05:39:11.000Z</published>
    <updated>2019-08-05T02:45:45.637Z</updated>
    
    <content type="html"><![CDATA[<p>Centos安装vmware不能正常使用。有可能是因为某些模块没有编译。</p><h3 id="Could-not-open-dev-vmmon"><a href="#Could-not-open-dev-vmmon" class="headerlink" title="Could not open /dev/vmmon"></a>Could not open /dev/vmmon</h3><p>安装界面可以打开，启动虚拟机时报错Could not open /dev/vmmon，是因为没有编译vmmon模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">tar xvf /usr/lib/vmware/modules/source/vmmon.tar</span><br><span class="line">cd vmmon-only</span><br><span class="line">make</span><br><span class="line">cp vmmon.ko /lib/modules/2.6.32-504.el6.x86_64/misc/vmmon.ko</span><br><span class="line">modprobe vmmon</span><br></pre></td></tr></table></figure><h3 id="打不开网络配置器vmware-ntcfg"><a href="#打不开网络配置器vmware-ntcfg" class="headerlink" title="打不开网络配置器vmware-ntcfg"></a>打不开网络配置器vmware-ntcfg</h3><p>点击网络设置没反应，命令使用vmware-ntecfg也没反应。因为没有编译vmnet模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">tar xvf /usr/lib/vmware/modules/source/vmnet.tar</span><br><span class="line">cd vmnet-only</span><br><span class="line">make</span><br><span class="line">cp vmnet.ko /lib/modules/2.6.32-504.el6.x86_64/misc/vmnet.ko</span><br><span class="line">modprobe vmnet</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Centos安装vmware不能正常使用。有可能是因为某些模块没有编译。&lt;/p&gt;
&lt;h3 id=&quot;Could-not-open-dev-vmmon&quot;&gt;&lt;a href=&quot;#Could-not-open-dev-vmmon&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dookt.com/categories/Linux/"/>
    
    
      <category term="虚拟化" scheme="http://www.dookt.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>k8s平台搭建</title>
    <link href="http://www.dookt.com/post/b2e09379.html"/>
    <id>http://www.dookt.com/post/b2e09379.html</id>
    <published>2019-08-01T12:04:01.000Z</published>
    <updated>2019-08-04T11:15:03.029Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes集群拥有一个Kubernetes Master。Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创建和复制Pod的Replication Controller。</p><h3 id="kubernetes平台环境"><a href="#kubernetes平台环境" class="headerlink" title="kubernetes平台环境"></a>kubernetes平台环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k8s master节点：172.16.100.11</span><br><span class="line">k8s node1节点：172.16.100.101</span><br><span class="line">k8s node2节点：172.16.100.102</span><br><span class="line">docker仓库节点：172.16.100.105</span><br></pre></td></tr></table></figure><h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">yum -y install ntp</span><br><span class="line">ntpdate pool.ntp.org</span><br><span class="line">systemctl start ntpd</span><br><span class="line">systemctl enable ntpd</span><br></pre></td></tr></table></figure><h3 id="K8S-master安装配置"><a href="#K8S-master安装配置" class="headerlink" title="K8S master安装配置"></a>K8S master安装配置</h3><h4 id="在master节点安装etcd、kubernetes和flanneld"><a href="#在master节点安装etcd、kubernetes和flanneld" class="headerlink" title="在master节点安装etcd、kubernetes和flanneld"></a>在master节点安装etcd、kubernetes和flanneld</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install kubernetes-master etcd flannel</span><br></pre></td></tr></table></figure><h4 id="配置master节点etcd"><a href="#配置master节点etcd" class="headerlink" title="配置master节点etcd"></a>配置master节点etcd</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/etcd/etcd.conf</span></span><br><span class="line">ETCD_NAME=etcd1</span><br><span class="line">ETCD_DATA_DIR="/data/etcd"</span><br><span class="line">ETCD_LISTEN_PEER_URLS="http://172.16.100.11:2380"</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS="http://172.16.100.11:2379,http://127.0.0.1:2379"</span><br><span class="line">ETCD_MAX_SNAPSHOTS="5"</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS="http://172.16.100.11:2380"</span><br><span class="line">ETCD_INITIAL_CLUSTER="etcd1=http://172.16.100.11:2380,etcd2=http://172.16.100.101:2380,etcd3=http://172.16.100.102:2380"</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS="http://172.16.100.11:2379"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建etcd数据目录</span></span><br><span class="line">mkdir  -p  /data/etcd/;chmod 757 -R /data/etcd/</span><br></pre></td></tr></table></figure><h4 id="修改-etc-kubernetes-config配置"><a href="#修改-etc-kubernetes-config配置" class="headerlink" title="修改/etc/kubernetes/config配置"></a>修改/etc/kubernetes/config配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/config </span></span><br><span class="line">KUBE_LOGTOSTDERR="--logtostderr=true"</span><br><span class="line">KUBE_LOG_LEVEL="--v=0"</span><br><span class="line">KUBE_ALLOW_PRIV="--allow-privileged=false"</span><br><span class="line">KUBE_MASTER="--master=http://172.16.100.11:8080"</span><br></pre></td></tr></table></figure><h4 id="修改kube-apiserver配置"><a href="#修改kube-apiserver配置" class="headerlink" title="修改kube-apiserver配置"></a>修改kube-apiserver配置</h4><p>将Kubernetes的apiserver进程的服务地址告诉Kubernetes的controller-manager, scheduler,proxy进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/apiserver</span></span><br><span class="line">KUBE_API_ADDRESS="--insecure-bind-address=0.0.0.0"</span><br><span class="line">KUBE_API_PORT="--port=8080"</span><br><span class="line">KUBELET_PORT="--kubelet-port=10250"</span><br><span class="line">KUBE_ETCD_SERVERS="--etcd-servers=http://172.16.100.11:2379,http://172.16.100.101:2379,http://172.16.100.102:2379"</span><br><span class="line">KUBE_SERVICE_ADDRESSES="--service-cluster-ip-range=10.254.0.0/16"</span><br><span class="line">KUBE_ADMISSION_CONTROL="--admission_control=NamespaceLifecycle,NamespaceExists,LimitRanger,ResourceQuota"</span><br><span class="line">KUBE_API_ARGS=""</span><br></pre></td></tr></table></figure><h4 id="启动master节点上的etcd-apiserver-controller-manager和scheduler"><a href="#启动master节点上的etcd-apiserver-controller-manager和scheduler" class="headerlink" title="启动master节点上的etcd, apiserver, controller-manager和scheduler"></a>启动master节点上的etcd, apiserver, controller-manager和scheduler</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for I in etcd kube-apiserver kube-controller-manager kube-scheduler;  do</span><br><span class="line">systemctl restart  $I</span><br><span class="line">systemctl enable  $I</span><br><span class="line">systemctl status   $I</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="K8S-node1节点配置"><a href="#K8S-node1节点配置" class="headerlink" title="K8S node1节点配置"></a>K8S node1节点配置</h3><h4 id="在node1节点上安装flannel、docker和Kubernetes"><a href="#在node1节点上安装flannel、docker和Kubernetes" class="headerlink" title="在node1节点上安装flannel、docker和Kubernetes"></a>在node1节点上安装flannel、docker和Kubernetes</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install kubernetes-node etcd docker flannel *rhsm* -y</span><br></pre></td></tr></table></figure><h4 id="配置node1节点etcd"><a href="#配置node1节点etcd" class="headerlink" title="配置node1节点etcd"></a>配置node1节点etcd</h4><p>配置信息告诉flannel进程etcd服务的位置以及在etcd上网络配置信息的节点位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/etcd/etc.conf</span></span><br><span class="line">ETCD_NAME=etcd2</span><br><span class="line">ETCD_DATA_DIR="/data/etcd"</span><br><span class="line">ETCD_LISTEN_PEER_URLS="http://172.16.100.101:2380"</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS="http://172.16.100.101:2379,http://127.0.0.1:2379"</span><br><span class="line">ETCD_MAX_SNAPSHOTS="5"</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS="http://172.16.100.101:2380"</span><br><span class="line">ETCD_INITIAL_CLUSTER="etcd1=http://172.16.100.11:2380,etcd2=http://172.16.100.101:2380,etcd3=http://172.16.100.102:2380"</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS="http://172.16.100.101:2379"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建etcd数据目录</span></span><br><span class="line">mkdir  -p  /data/etcd/;chmod 757 -R /data/etcd/</span><br></pre></td></tr></table></figure><h4 id="修改-etc-kubernetes-config配置-1"><a href="#修改-etc-kubernetes-config配置-1" class="headerlink" title="修改/etc/kubernetes/config配置"></a>修改/etc/kubernetes/config配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/config</span></span><br><span class="line">KUBE_LOGTOSTDERR="--logtostderr=true"</span><br><span class="line">KUBE_LOG_LEVEL="--v=0"</span><br><span class="line">KUBE_ALLOW_PRIV="--allow-privileged=false"</span><br><span class="line">KUBE_MASTER="--master=http://172.16.100.11:8080"</span><br></pre></td></tr></table></figure><h4 id="修改kubelet配置"><a href="#修改kubelet配置" class="headerlink" title="修改kubelet配置"></a>修改kubelet配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/kubelet</span></span><br><span class="line">KUBELET_ADDRESS="--address=0.0.0.0"</span><br><span class="line">KUBELET_PORT="--port=10250"</span><br><span class="line">KUBELET_HOSTNAME="--hostname-override=172.16.100.101"</span><br><span class="line">KUBELET_API_SERVER="--api-servers=http://172.16.100.11:8080"</span><br><span class="line">KUBELET_POD_INFRA_CONTAINER="--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest"</span><br><span class="line">KUBELET_ARGS=""</span><br></pre></td></tr></table></figure><h4 id="启动kube-proxy、kubelet、docker并查看其状态"><a href="#启动kube-proxy、kubelet、docker并查看其状态" class="headerlink" title="启动kube-proxy、kubelet、docker并查看其状态"></a>启动kube-proxy、kubelet、docker并查看其状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for I in kube-proxy kubelet docker</span><br><span class="line">do</span><br><span class="line">systemctl  enable  $I</span><br><span class="line">systemctl  restart  $I</span><br><span class="line">systemctl  status  $I</span><br><span class="line">done</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><h3 id="K8S-node1节点配置-1"><a href="#K8S-node1节点配置-1" class="headerlink" title="K8S node1节点配置"></a>K8S node1节点配置</h3><h4 id="在node2节点上安装flannel、docker和Kubernetes"><a href="#在node2节点上安装flannel、docker和Kubernetes" class="headerlink" title="在node2节点上安装flannel、docker和Kubernetes"></a>在node2节点上安装flannel、docker和Kubernetes</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install kubernetes-node etcd docker flannel *rhsm* -y</span><br></pre></td></tr></table></figure><h4 id="配置node1节点etcd-1"><a href="#配置node1节点etcd-1" class="headerlink" title="配置node1节点etcd"></a>配置node1节点etcd</h4><p>配置信息告诉flannel进程etcd服务的位置以及在etcd上网络配置信息的节点位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/etcd/etc.conf</span></span><br><span class="line">ETCD_NAME=etcd3</span><br><span class="line">ETCD_DATA_DIR="/data/etcd"</span><br><span class="line">ETCD_LISTEN_PEER_URLS="http://172.16.100.102:2380"</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS="http://172.16.100.102:2379,http://127.0.0.1:2379"</span><br><span class="line">ETCD_MAX_SNAPSHOTS="5"</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS="http://172.16.100.102:2380"</span><br><span class="line">ETCD_INITIAL_CLUSTER="etcd1=http://172.16.100.11:2380,etcd2=http://172.16.100.101:2380,etcd3=http://172.16.100.102:2380"</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS="http://172.16.100.102:2379"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建etcd数据目录</span></span><br><span class="line">mkdir  -p  /data/etcd/;chmod 757 -R /data/etcd/</span><br></pre></td></tr></table></figure><h4 id="修改-etc-kubernetes-config配置-2"><a href="#修改-etc-kubernetes-config配置-2" class="headerlink" title="修改/etc/kubernetes/config配置"></a>修改/etc/kubernetes/config配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/config</span></span><br><span class="line">KUBE_LOGTOSTDERR="--logtostderr=true"</span><br><span class="line">KUBE_LOG_LEVEL="--v=0"</span><br><span class="line">KUBE_ALLOW_PRIV="--allow-privileged=false"</span><br><span class="line">KUBE_MASTER="--master=http://172.16.100.11:8080"</span><br></pre></td></tr></table></figure><h4 id="修改kubelet配置-1"><a href="#修改kubelet配置-1" class="headerlink" title="修改kubelet配置"></a>修改kubelet配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/kubelet</span></span><br><span class="line">KUBELET_ADDRESS="--address=0.0.0.0"</span><br><span class="line">KUBELET_PORT="--port=10250"</span><br><span class="line">KUBELET_HOSTNAME="--hostname-override=172.16.100.102"</span><br><span class="line">KUBELET_API_SERVER="--api-servers=http://172.16.100.11:8080"</span><br><span class="line">KUBELET_POD_INFRA_CONTAINER="--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest"</span><br><span class="line">KUBELET_ARGS=""</span><br></pre></td></tr></table></figure><h4 id="启动kube-proxy、kubelet、docker并查看其状态-1"><a href="#启动kube-proxy、kubelet、docker并查看其状态-1" class="headerlink" title="启动kube-proxy、kubelet、docker并查看其状态"></a>启动kube-proxy、kubelet、docker并查看其状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for  I  in  kube-proxy  kubelet  docker</span><br><span class="line">do</span><br><span class="line">systemctl  enable  $I</span><br><span class="line">systemctl  restart  $I</span><br><span class="line">systemctl  status  $I</span><br><span class="line">done</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><h3 id="K8S-Flanneld网络配置"><a href="#K8S-Flanneld网络配置" class="headerlink" title="K8S Flanneld网络配置"></a>K8S Flanneld网络配置</h3><p>k8s的node节点搭建和配置flannel网络，etcd中/atomic.io/network/config节点会被Node节点上的flannel用来创建Doker IP地址网段。k8s集群所有节点都需要配置flanneld网络，如下，配置完成之后依次重启flanneld。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/sysconfig/flanneld</span></span><br><span class="line">FLANNEL_ETCD_ENDPOINTS="http://172.16.100.11:2379"</span><br><span class="line">FLANNEL_ETCD_PREFIX="/atomic.io/network"</span><br></pre></td></tr></table></figure><p>重启flanneld失败，原因是etcd中没有创建flannel网络</p><h4 id="创建flanneld网络"><a href="#创建flanneld网络" class="headerlink" title="创建flanneld网络"></a>创建flanneld网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl  mk  /atomic.io/network/config '&#123;"Network":"172.17.0.0/16"&#125;'</span><br></pre></td></tr></table></figure><h4 id="etcd使用"><a href="#etcd使用" class="headerlink" title="etcd使用"></a>etcd使用</h4><p>在master节点上测试etcd集群是否正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">etcdctl  member list</span><br><span class="line">etcdctl cluster-health</span><br><span class="line">etcdctl get /atomic.io/network/config</span><br><span class="line">etcdctl ls /atomic.io/network/subnets</span><br><span class="line">etcdctl  rm   /atomic.io/network/   --recursive</span><br><span class="line">etcdctl  mk  /atomic.io/network/config &apos;&#123;&quot;Network&quot;:&quot;172.17.0.0/16&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><h3 id="K8S-Dashborad-UI"><a href="#K8S-Dashborad-UI" class="headerlink" title="K8S Dashborad UI"></a>K8S Dashborad UI</h3><p>k8s实现的最重要的工作是对Docker容器集群统一的管理和调度，通常使用命令行来操作Kubernetes集群及各个节点，命令行操作非常不方便，如果使用UI界面来可视化操作，会更加方便的管理和维护。</p><p>由于官网下载镜像太慢，提前下载好以下两个镜像：</p><ul><li>pod-infrastructure</li><li>kubernetes-dashboard-amd64</li></ul><h4 id="Docker镜像导入并修改名称"><a href="#Docker镜像导入并修改名称" class="headerlink" title="Docker镜像导入并修改名称"></a>Docker镜像导入并修改名称</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; pod-infrastructure.tgz</span><br><span class="line">docker tag $(docker images|grep none|awk '&#123;print $3&#125;') registry.access.redhat.com/rhel7/pod-infrastructure</span><br><span class="line">docker load &lt;kubernetes-dashboard-amd64.tgz</span><br><span class="line">docker tag $(docker images|grep none|awk '&#123;print $3&#125;') bestwu/kubernetes-dashboard-amd64:v1.6.3</span><br></pre></td></tr></table></figure><h4 id="在master创建dashboard-controller-yaml"><a href="#在master创建dashboard-controller-yaml" class="headerlink" title="在master创建dashboard-controller.yaml"></a>在master创建dashboard-controller.yaml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="string">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">scheduler.alpha.kubernetes.io/critical-pod:</span> <span class="string">''</span></span><br><span class="line">        <span class="string">scheduler.alpha.kubernetes.io/tolerations:</span> <span class="string">'[&#123;"key":"CriticalAddonsOnly", "operator":"Exists"&#125;]'</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">bestwu/kubernetes-dashboard-amd64:v1.6.3</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line">          <span class="comment"># keep request = limit to keep this container in guaranteed class</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">50</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">50</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">        args:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="bullet">--apiserver-host=http://172.16.100.11:8080</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">            port:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">          timeoutSeconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><h4 id="在master上创建dashboard-service-yaml"><a href="#在master上创建dashboard-service-yaml" class="headerlink" title="在master上创建dashboard-service.yaml"></a>在master上创建dashboard-service.yaml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="string">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure><h4 id="创建dashborad-pods实例"><a href="#创建dashborad-pods实例" class="headerlink" title="创建dashborad pods实例"></a>创建dashborad pods实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f dashboard-controller.yaml</span><br><span class="line">kubectl create -f dashboard-service.yaml</span><br></pre></td></tr></table></figure><h4 id="查看pods和service信息"><a href="#查看pods和service信息" class="headerlink" title="查看pods和service信息"></a>查看pods和service信息</h4><p>因为默认查询到的namespace是default下的，所以需要指定namespace </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl  get  namespace</span><br><span class="line">kubectl get  deployment --all-namespaces</span><br><span class="line">kubectl get  svc  --all-namespaces</span><br><span class="line">kubectl  get  pods  --all-namespaces</span><br><span class="line">kubectl get pod  -o wide  --all-namespaces</span><br><span class="line">kubectl  describe  service/kubernetes-dashboard  --namespace="kube-system"</span><br><span class="line">kubectl  describe  pod/kubernetes-dashboard-530803917-816df --namespace="kube-system"</span><br><span class="line">kubectl  delete pod/kubernetes-dashboard-530803917-816df --namespace="kube-system" --grace-period=0 --force</span><br></pre></td></tr></table></figure><h3 id="访问k8s-dasborad-UI"><a href="#访问k8s-dasborad-UI" class="headerlink" title="访问k8s dasborad UI"></a>访问k8s dasborad UI</h3><p>通过浏览器访问：<a href="http://172.16.100.11/ui" target="_blank" rel="noopener">http://172.16.100.11/ui</a></p><h3 id="访问ui有问题提示"><a href="#访问ui有问题提示" class="headerlink" title="访问ui有问题提示"></a>访问ui有问题提示</h3><ul><li>注意dashborad-controller.yaml中定义的apiserver-host 是否正确</li><li>使用iptables -P FORWARD ACCEPT </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kubernetes集群拥有一个Kubernetes Master。Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创
      
    
    </summary>
    
      <category term="k8s" scheme="http://www.dookt.com/categories/k8s/"/>
    
    
      <category term="容器" scheme="http://www.dookt.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Nginx设置为系统服务</title>
    <link href="http://www.dookt.com/post/c6b0c30c.html"/>
    <id>http://www.dookt.com/post/c6b0c30c.html</id>
    <published>2019-07-31T11:17:37.000Z</published>
    <updated>2019-07-31T11:21:12.160Z</updated>
    
    <content type="html"><![CDATA[<p>通过官网下载NGinx源码安装部署时。每次都是需要手动进入安装目录下管理Nginx。很是麻烦，写个脚本实现Nginx应用的启动、停止、重载。并可以使用service来管理实现开机自启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: - 85 15</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: Nginx Web Server </span></span><br><span class="line"></span><br><span class="line">Dir=/usr/local/nginx/</span><br><span class="line">Config=/usr/local/nginx/sbin/nginx</span><br><span class="line">Pidfile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line"></span><br><span class="line">. /etc/init.d/functions</span><br><span class="line"></span><br><span class="line">start()&#123;</span><br><span class="line">    if [ ! -f $Pidfile ];then</span><br><span class="line">        $Config</span><br><span class="line">        NUM=$?</span><br><span class="line">        if [ $NUM -ne 0 ];then</span><br><span class="line">            action "NGINX starting..." /bin/false</span><br><span class="line">            return $NUM</span><br><span class="line">        else</span><br><span class="line">            action "NGINX starting..." /bin/true</span><br><span class="line">            return $NUM</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        echo "NGINX is running"</span><br><span class="line">        return $NUM</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    if [ -f $Pidfile ];then</span><br><span class="line">        $Config -s stop</span><br><span class="line">        NUM=$?</span><br><span class="line">        if [ $NUM -ne 0 ];then</span><br><span class="line">            action "NGINX stopping..." /bin/false</span><br><span class="line">            return $NUM</span><br><span class="line">        else</span><br><span class="line">            action "NGINX stopping..." /bin/true</span><br><span class="line">            return $NUM</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        echo "NGINX is not running"</span><br><span class="line">        return $NUM            </span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">status() &#123;</span><br><span class="line">    if [ `ps -ef | grep nginx | grep -vc grep` -gt 1 ];then</span><br><span class="line">        echo -e "\033[32mNGINX is running\033[0m"</span><br><span class="line">    else</span><br><span class="line">        echo -e "\033[31mNGINX is not running\033[0m"</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        stop</span><br><span class="line">        sleep 2</span><br><span class="line">        start</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo $"Usage: $0 &#123;start|stop|restart|status&#125;"</span><br><span class="line">        exit 9</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line">exit $NUM</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过官网下载NGinx源码安装部署时。每次都是需要手动进入安装目录下管理Nginx。很是麻烦，写个脚本实现Nginx应用的启动、停止、重载。并可以使用service来管理实现开机自启动。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="Nginx" scheme="http://www.dookt.com/categories/Nginx/"/>
    
    
      <category term="Scripts" scheme="http://www.dookt.com/tags/Scripts/"/>
    
      <category term="Nginx" scheme="http://www.dookt.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat设置为系统服务</title>
    <link href="http://www.dookt.com/post/a2c1797d.html"/>
    <id>http://www.dookt.com/post/a2c1797d.html</id>
    <published>2019-07-31T11:09:33.000Z</published>
    <updated>2019-07-31T11:13:55.816Z</updated>
    
    <content type="html"><![CDATA[<p>通过官网下载Tomcat二进制包来安装部署Tomcat。每次都是需要手动进入bin目录下管理Tomcat程序。很是麻烦，写个脚本实现Tomcat应用的启动、停止。并可以使用service来管理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: 2345 99 10</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: Tomcat service manage script</span></span><br><span class="line"></span><br><span class="line">. /etc/init.d/functions</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_112/</span><br><span class="line">export CATALINA_HOME=/opt/apache-tomcat-9.0.4</span><br><span class="line"></span><br><span class="line">Usage() &#123;</span><br><span class="line">    echo $"Usage: $0 &#123;start|stop|restart|status&#125;"</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">    if [ -f $CATALINA_HOME/bin/startup.sh ];then</span><br><span class="line">        $CATALINA_HOME/bin/startup.sh &amp;&gt; /dev/null</span><br><span class="line">        NUM=$?</span><br><span class="line">        if [ $NUM -eq 0 ];then</span><br><span class="line">            action "Tomcat started..." /bin/true</span><br><span class="line">            return $NUM</span><br><span class="line">        else</span><br><span class="line">            action "Tomcat started..." /bin/false</span><br><span class="line">            return $NUM</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    if [ -f $CATALINA_HOME/bin/shutdown.sh ];then</span><br><span class="line">        $CATALINA_HOME/bin/shutdown.sh &amp;&gt; /dev/null</span><br><span class="line">        NUM=$?</span><br><span class="line">        if [ $NUM -eq 0 ];then</span><br><span class="line">            action "Tomcat stopped..." /bin/true</span><br><span class="line">            return $NUM</span><br><span class="line">        else</span><br><span class="line">            action "Tomcat stopped..." /bin/false</span><br><span class="line">            return $NUM</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status() &#123;</span><br><span class="line">    if [ `ps -ef | grep java | grep -vc grep` -ge 1 ];then</span><br><span class="line">       echo -e "\033[32mTomcat is running\033[0m" </span><br><span class="line">    else</span><br><span class="line">       echo -e "\033[31mTomcat is not running\033[0m" </span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        stop</span><br><span class="line">        sleep 2</span><br><span class="line">        start</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        Usage</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit $NUM</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过官网下载Tomcat二进制包来安装部署Tomcat。每次都是需要手动进入bin目录下管理Tomcat程序。很是麻烦，写个脚本实现Tomcat应用的启动、停止。并可以使用service来管理。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dookt.com/categories/Linux/"/>
    
    
      <category term="Scripts" scheme="http://www.dookt.com/tags/Scripts/"/>
    
      <category term="Tomcat" scheme="http://www.dookt.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Python编写zabbix告警邮件</title>
    <link href="http://www.dookt.com/post/7df7e5a.html"/>
    <id>http://www.dookt.com/post/7df7e5a.html</id>
    <published>2019-07-31T11:06:26.000Z</published>
    <updated>2019-07-31T11:08:16.843Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python编写一个脚本，实现zabbix邮件告警</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">mail_host = <span class="string">'smtp.163.com'</span></span><br><span class="line">mail_user = <span class="string">'1831317'</span></span><br><span class="line">mail_pass = <span class="string">'******'</span></span><br><span class="line">mail_postfix = <span class="string">'163.com'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(to_list,subject,content)</span>:</span></span><br><span class="line">    me = <span class="string">"zabbix监控告警平台"</span>+<span class="string">"&lt;"</span>+mail_user+<span class="string">"@"</span>+mail_postfix+<span class="string">"&gt;"</span></span><br><span class="line">    msg = MIMEText(content, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg[<span class="string">'Subject'</span>] = subject</span><br><span class="line">    msg[<span class="string">'From'</span>] = me</span><br><span class="line">    msg[<span class="string">'to'</span>] = to_list</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = smtplib.SMTP()</span><br><span class="line">        s.connect(mail_host)</span><br><span class="line">        s.login(mail_user,mail_pass)</span><br><span class="line">        s.sendmail(me,to_list,msg.as_string())</span><br><span class="line">        s.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception,e:</span><br><span class="line">        <span class="keyword">print</span> str(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    send_mail(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Python编写一个脚本，实现zabbix邮件告警&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="Python" scheme="http://www.dookt.com/categories/Python/"/>
    
    
      <category term="Zabbix" scheme="http://www.dookt.com/tags/Zabbix/"/>
    
      <category term="监控" scheme="http://www.dookt.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile生成镜像</title>
    <link href="http://www.dookt.com/post/4120479c.html"/>
    <id>http://www.dookt.com/post/4120479c.html</id>
    <published>2019-07-31T11:01:46.000Z</published>
    <updated>2019-07-31T11:03:39.322Z</updated>
    
    <content type="html"><![CDATA[<p>使用Dockerfile生成一个可以使用ssh的Centos基础镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM centos                                                                                                          </span><br><span class="line"><span class="comment">#指定基础镜像</span></span><br><span class="line">MAINTAINER mint</span><br><span class="line"><span class="comment">#制定维护者</span></span><br><span class="line">RUN yum -y install passwd openssl openssh-server&amp;&amp; <span class="built_in">echo</span> <span class="string">'123456'</span>|passwd --stdin root</span><br><span class="line">RUN ssh-keygen -q -t rsa -b 2048 -f /etc/ssh/ssh_host_rsa_key -N <span class="string">''</span></span><br><span class="line">RUN ssh-keygen -q -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N <span class="string">''</span></span><br><span class="line">RUN sed -i <span class="string">'/^session\s\+required\s\+pam_loginuid.so/s/^/#/'</span> /etc/pam.d/sshd</span><br><span class="line">RUN mkdir -p /root/.ssh &amp;&amp; chown root. /root &amp;&amp; chmod 700 /root/.ssh &amp;&amp; cp /etc/skel/.bash* /root</span><br><span class="line">EXPOSE 22</span><br><span class="line"><span class="comment">#暴露ssh端口</span></span><br><span class="line">CMD ip addr ls eth0|awk <span class="string">'&#123;print $2&#125;'</span>|egrep -o <span class="string">'([0-9]+\.)&#123;3&#125;[0-9]+'</span>;/usr/sbin/sshd -D</span><br><span class="line"><span class="comment">#设定运行镜时,输出IP,并以daemon的方式启动sshd</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Dockerfile生成一个可以使用ssh的Centos基础镜像&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dookt.com/categories/Linux/"/>
    
    
      <category term="Docker" scheme="http://www.dookt.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins发布脚本</title>
    <link href="http://www.dookt.com/post/d936a15c.html"/>
    <id>http://www.dookt.com/post/d936a15c.html</id>
    <published>2019-07-31T10:56:28.000Z</published>
    <updated>2019-08-03T10:47:39.320Z</updated>
    
    <content type="html"><![CDATA[<p>使用jenkins来进行业务升级、回滚、备份等功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定义变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> -x</span></span><br><span class="line"></span><br><span class="line">APPDIR=$2                               #应用所在目录，/opt/app</span><br><span class="line">APPNAME=$3                              #应用名称，如test-llb-dubbo-21996</span><br><span class="line">ENV=$4                                  #如tdtp,ttsp</span><br><span class="line">TOMCATWAR=$5                            #Tomcat应用webapps下的内容</span><br><span class="line">SERVER_PORT=$6                          #应用启动的端口，如21996</span><br><span class="line">TARDIR=/opt/package                     #应用tar包存放目录，如/opt/package</span><br><span class="line">BAKDIR=/opt/backup                      #应用备份目录，如/opt/backup/</span><br><span class="line">LOGDIR=/opt/logs                        #应用日志目录，如/opt/logs</span><br><span class="line">BINDIR=$&#123;APPDIR&#125;/$&#123;APPNAME&#125;/bin         #脚本所在目录，如/opt/app/test-llb-dubbo-20889/bin/</span><br><span class="line">DEPLOY_DIR=$&#123;APPDIR&#125;/$&#123;APPNAME&#125;         #应用发布目录，如/opt/app/test-llb-dubbo-20889</span><br><span class="line">PARAMNUM=$#                             #传入的参数个数</span><br><span class="line">SCRIPTNAME=$0                           #脚本名称</span><br><span class="line"><span class="meta">#</span><span class="bash">SHELLLOG=<span class="string">"<span class="variable">$&#123;LOGDIR&#125;</span>/<span class="variable">$&#123;SCRIPTNAME&#125;</span>.log"</span>  <span class="comment">#存放脚本操作日志文件</span></span></span><br><span class="line">CONFIG_SERVER=172.16.100.11             #jenkins上的nginx服务器地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用帮助</span></span><br><span class="line"></span><br><span class="line">function usage() &#123;</span><br><span class="line">    if [[ $&#123;PARAMNUM&#125; -ne 6 ]];then</span><br><span class="line">        echo "Usage: $0 start|stop|restart|publish|rollback APPDIR APPNAME ENV TOMCATWAR SERVER_PORT"</span><br><span class="line">        exit 11</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">start <span class="keyword">function</span></span></span><br><span class="line">function start() &#123;</span><br><span class="line">    PIDS=`ps -ef | grep java | grep "$&#123;DEPLOY_DIR&#125;" |awk '&#123;print $2&#125;'`</span><br><span class="line">    #判断应用是否启动</span><br><span class="line">    if [[ -n "$&#123;PIDS&#125;" ]];then</span><br><span class="line">        echo "ERROR: The $&#123;APPNAME&#125; already started!"</span><br><span class="line">        echo "PID: $PIDS"</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">chown -R app. /opt</span><br><span class="line">    </span><br><span class="line">    #判断端口是否被占用</span><br><span class="line">    if [[ -n $&#123;SERVER_PORT&#125; ]];then</span><br><span class="line">        SERVER_PORT_COUNT=`netstat -tln | grep $&#123;SERVER_PORT&#125; | wc -l`</span><br><span class="line">        if [[ $&#123;SERVER_PORT_COUNT&#125; -gt 0 ]]; then</span><br><span class="line">            echo "ERROR: The $&#123;APPNAME&#125; port $&#123;SERVER_PORT&#125; already used!"</span><br><span class="line">            return 2</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    #执行启动脚本</span><br><span class="line">    echo -e "Starting the $&#123;APPNAME&#125; ...\c"</span><br><span class="line">    sleep 2</span><br><span class="line"></span><br><span class="line">    #判断是不是dubbo应用</span><br><span class="line">result=$(echo $&#123;APPNAME&#125;| grep -vE "tomcat|bom")</span><br><span class="line">if [[ "$&#123;result&#125;" != "" ]];then</span><br><span class="line">        source /etc/profile &amp;&amp; cd $&#123;BINDIR&#125; &amp;&amp; /bin/bash $&#123;BINDIR&#125;/start.sh</span><br><span class="line">    else</span><br><span class="line">        source /etc/profile &amp;&amp; cd $&#123;BINDIR&#125; &amp;&amp; nohup /bin/bash $&#123;BINDIR&#125;/startup.sh &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 判断应用是否启动成功</span><br><span class="line">    COUNT=0  # 计算java 进程个数</span><br><span class="line">    flag=0   # 计算启动时间秒数</span><br><span class="line">    while [[ $&#123;COUNT&#125; -lt 1 ]]; do</span><br><span class="line">        echo -e ".\c"  # 等同于 echo -n "."</span><br><span class="line">        sleep 1</span><br><span class="line">        if [[ -n "$&#123;SERVER_PORT&#125;" ]]; then</span><br><span class="line">            COUNT=`netstat -ant | grep $&#123;SERVER_PORT&#125; | wc -l`</span><br><span class="line">        else</span><br><span class="line">            COUNT=`ps -f | grep java | grep "$&#123;DEPLOY_DIR&#125;" | awk '&#123;print $2&#125;' | wc -l`</span><br><span class="line">        fi</span><br><span class="line">        if [[ $&#123;COUNT&#125; -gt 0 ]]; then</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line">        # 判断启动30s后，端口或进程不存在，表示启动失败</span><br><span class="line">        flag=$[$&#123;flag&#125;+1]</span><br><span class="line">        if [[ $&#123;flag&#125; -gt 30 ]] &amp;&amp; [[ $&#123;COUNT&#125; -eq 0 ]]; then</span><br><span class="line">            echo "应用启动失败"</span><br><span class="line">            exit 33</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">    </span><br><span class="line">    #输出启动成功信息</span><br><span class="line">    echo "OK!"</span><br><span class="line">    PIDS=`ps -f | grep java | grep "$&#123;DEPLOY_DIR&#125;" | awk '&#123;print $2&#125;'`</span><br><span class="line">    echo "Start $&#123;APPNAME&#125; Success, PID: $PIDS"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> stop <span class="keyword">function</span></span></span><br><span class="line">function stop() &#123;</span><br><span class="line">    PIDS=`ps -ef | grep java | grep "$&#123;DEPLOY_DIR&#125;" |awk '&#123;print $2&#125;'`    </span><br><span class="line">    #判断应用是否已经停止</span><br><span class="line">    if [[ -z "$PIDS" ]]; then</span><br><span class="line">        echo "ERROR: The $&#123;APPNAME&#125; does not started!"</span><br><span class="line">        return 4</span><br><span class="line">    fi</span><br><span class="line">    #停止应用进程</span><br><span class="line">    echo -e "Stopping the $&#123;APPNAME&#125; ...\c"</span><br><span class="line">    for PID in $&#123;PIDS&#125; ; do</span><br><span class="line">        kill $&#123;PID&#125; &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">     #判断应用是否停止成功，等待时间15s</span><br><span class="line">     COUNT=0</span><br><span class="line">     while [[ $&#123;COUNT&#125; -lt 15 ]]; do</span><br><span class="line">         echo -e ".\c"</span><br><span class="line">         sleep 1</span><br><span class="line">         COUNT=$[$&#123;COUNT&#125;+1]</span><br><span class="line">     done</span><br><span class="line"></span><br><span class="line">      # 停止进程超过15s，直接kill -9</span><br><span class="line">      PIDS_EXIST=`ps -ef | grep java | grep "$&#123;DEPLOY_DIR&#125;" |awk '&#123;print $2&#125;'`</span><br><span class="line">      echo $&#123;PIDS_EXIST&#125;</span><br><span class="line">      if [[ -n "$&#123;PIDS_EXIST&#125;" ]]; then</span><br><span class="line">          for PID in $&#123;PIDS_EXIST&#125; ; do</span><br><span class="line">              kill -9 $&#123;PID&#125; &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">          done</span><br><span class="line">      fi</span><br><span class="line"></span><br><span class="line">      # 输出停止成功信息</span><br><span class="line">      echo "OK!"</span><br><span class="line">      echo "Stop $&#123;APPNAME&#125; Success, PID: $PIDS"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> backup <span class="keyword">function</span></span></span><br><span class="line">function backup() &#123;</span><br><span class="line">    cd $&#123;APPDIR&#125;</span><br><span class="line">    #判断应用目录是否存在</span><br><span class="line">    if [[ ! -d $&#123;APPNAME&#125; ]];then</span><br><span class="line">        echo "ERROR: $&#123;DEPLOY_DIR&#125; is not existed."</span><br><span class="line">        return 5</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    mv $&#123;APPNAME&#125; $&#123;BAKDIR&#125;/$&#123;APPNAME&#125;_`date +%F_%T`</span><br><span class="line"></span><br><span class="line">    #判断是否备份成功</span><br><span class="line">    if [[ $? -eq 0 ]];then</span><br><span class="line">        echo "Backup $&#123;APPNAME&#125; sucess!"</span><br><span class="line">    else</span><br><span class="line">        echo "Backup $&#123;APPNAME&#125; failed!"</span><br><span class="line">        exit 6</span><br><span class="line">    fi</span><br><span class="line">    cd $&#123;BAKDIR&#125;</span><br><span class="line">    find . -mtime +30 -name "*$&#123;APPNAME&#125;*" -exec rm -rf &#123;&#125; \;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">deploy <span class="keyword">function</span></span></span><br><span class="line">function deploy() &#123;</span><br><span class="line">    #解压需要更新的应用包到应用目录</span><br><span class="line">    </span><br><span class="line">    #判断是否是dubbo应用</span><br><span class="line">result=$(echo $&#123;APPNAME&#125;| grep -vE "tomcat|bom")</span><br><span class="line">if [[ "$&#123;result&#125;" != "" ]];then</span><br><span class="line">        mkdir -p "$&#123;APPDIR&#125;/$&#123;APPNAME&#125;"</span><br><span class="line">        cd $&#123;APPDIR&#125;/$&#123;APPNAME&#125;</span><br><span class="line">        #下载应用包,解压文件夹</span><br><span class="line">        wget http://$&#123;CONFIG_SERVER&#125;/$&#123;ENV&#125;/$&#123;APPNAME&#125;.tar -O $&#123;TARDIR&#125;/$&#123;APPNAME&#125;.tar</span><br><span class="line">        tar -xf $&#123;TARDIR&#125;/$&#123;APPNAME&#125;.tar -C $&#123;APPDIR&#125;</span><br><span class="line">        sleep 3</span><br><span class="line">        if [[ ! -d $&#123;LOGDIR&#125; ]];then</span><br><span class="line">            mkdir -p $&#123;LOGDIR&#125;</span><br><span class="line">        fi</span><br><span class="line">        #判断应用目录日志文件是否是软连接</span><br><span class="line">        if [[ ! -L $&#123;APPNAME&#125;/log ]];then</span><br><span class="line">            #判断应用目录日志文件夹是否是文件夹</span><br><span class="line">            if [[ -d $&#123;APPNAME&#125;/logs ]]; then</span><br><span class="line">                mv $&#123;APPNAME&#125;/logs/* $&#123;LOGDIR&#125;</span><br><span class="line">                rmdir $&#123;APPNAME&#125;/logs</span><br><span class="line">            fi</span><br><span class="line">            ln -s $&#123;LOGDIR&#125; $&#123;APPDIR&#125;/$&#123;APPNAME&#125;/logs </span><br><span class="line">        else</span><br><span class="line">            echo "日志文件已经是软链接"</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line"><span class="meta">#</span><span class="bash">如果是tomcat应用</span></span><br><span class="line">        #获取到tomcat包保存在包目录</span><br><span class="line">wget http://$&#123;CONFIG_SERVER&#125;/tomcat-8.5.29.tar.gz -O $&#123;TARDIR&#125;/tomcat-8.5.29.tar.gz</span><br><span class="line">        #判断是否存在tomcat应用目录</span><br><span class="line">        if [[ ! -d $&#123;APPDIR&#125;/$&#123;APPNAME&#125; ]];then</span><br><span class="line">            #解压文件夹</span><br><span class="line">            cd $&#123;APPDIR&#125; &amp;&amp; tar xf $&#123;TARDIR&#125;/tomcat-8.5.29.tar.gz -C . &amp;&amp; rm -rf ./tomcat-8.5.29/webapps  &amp;&amp; mv tomcat-8.5.29 $&#123;APPNAME&#125;</span><br><span class="line">wget http://$&#123;CONFIG_SERVER&#125;/$&#123;ENV&#125;/$&#123;APPNAME&#125;.tar -O $&#123;TARDIR&#125;/$&#123;APPNAME&#125;.tar</span><br><span class="line">cd $&#123;TARDIR&#125; &amp;&amp; tar xf $&#123;APPNAME&#125;.tar &amp;&amp; mv $&#123;APPNAME&#125;/webapps $&#123;APPDIR&#125;/$&#123;APPNAME&#125; &amp;&amp; rm -rf $&#123;APPNAME&#125;</span><br><span class="line">sleep 3</span><br><span class="line">            if [[ ! -d $&#123;LOGDIR&#125; ]];then</span><br><span class="line">                mkdir -p $&#123;LOGDIR&#125;</span><br><span class="line">            fi</span><br><span class="line"><span class="meta">#</span><span class="bash">判断应用目录日志文件是否是软连接</span></span><br><span class="line">        if [[ ! -L $&#123;APPNAME&#125;/log ]];then</span><br><span class="line">            #判断应用目录日志文件夹是否是文件夹</span><br><span class="line">            if [[ -d $&#123;APPNAME&#125;/logs ]]; then</span><br><span class="line">                mv $&#123;APPNAME&#125;/logs/* $&#123;LOGDIR&#125;</span><br><span class="line">                rmdir $&#123;APPNAME&#125;/logs</span><br><span class="line">            fi</span><br><span class="line">            ln -s $&#123;LOGDIR&#125; $&#123;APPDIR&#125;/$&#123;APPNAME&#125;/logs</span><br><span class="line">        else</span><br><span class="line">            echo "日志文件已经是软链接"</span><br><span class="line">        fi</span><br><span class="line">        fi</span><br><span class="line">            </span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">rollback <span class="keyword">function</span></span></span><br><span class="line">function rollback() &#123;</span><br><span class="line">    cd $&#123;APPDIR&#125;</span><br><span class="line">result=$(echo $&#123;APPNAME&#125; | grep -vE "tomcat|bom")</span><br><span class="line">if [[ "$&#123;result&#125;" = "" ]];then</span><br><span class="line">        [[ -d $&#123;APPNAME&#125; ]] &amp;&amp; rm -rf $&#123;APPNAME&#125;</span><br><span class="line">        mv $&#123;BAKDIR&#125;/`ls -rht $&#123;BAKDIR&#125;|grep $&#123;APPNAME&#125;|tail -1` $&#123;APPNAME&#125;</span><br><span class="line">    else</span><br><span class="line">        [[ -d $&#123;APPNAME&#125; ]] &amp;&amp; rm -rf $&#123;APPNAME&#125;/webapps/</span><br><span class="line">        mv $&#123;BAKDIR&#125;/`ls -rht $&#123;BAKDIR&#125;|grep webapps|tail -1` $&#123;APPNAME&#125;/</span><br><span class="line">    fi</span><br><span class="line">    #输出应用回滚成功信息</span><br><span class="line">    echo "Rollback $&#123;APPNAME&#125; sucess!"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case $1 in </span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    publish)</span><br><span class="line">        stop</span><br><span class="line">        backup</span><br><span class="line">        deploy</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    rollback)</span><br><span class="line">        stop</span><br><span class="line">        rollback</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        usage</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用jenkins来进行业务升级、回滚、备份等功能&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://www.dookt.com/categories/Jenkins/"/>
    
    
      <category term="Scripts" scheme="http://www.dookt.com/tags/Scripts/"/>
    
      <category term="Jenkins" scheme="http://www.dookt.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>k8s-一个简单的例子</title>
    <link href="http://www.dookt.com/post/d6261197.html"/>
    <id>http://www.dookt.com/post/d6261197.html</id>
    <published>2019-07-31T02:14:21.000Z</published>
    <updated>2019-07-31T05:34:36.892Z</updated>
    
    <content type="html"><![CDATA[<p>使用k8s部署一个Java WEB应用。该应用运行在Tomcat里的Web App。需要启动两个容器：WEB容器和MySQL容器，并且Web App需要访问MySQL容器。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>使用vmware+centos7.2。安装系统完成之后，首先关闭防火墙，selinux，安装和下载k8s相关镜像，使用kubeadm快速安装一个k8s集群</p><ul><li>宿主机IP：172.16.100.11</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@spareribs ~]# systemctl stop firewalld</span><br><span class="line">[root@spareribs ~]# systemctl disable firewalld</span><br><span class="line">[root@spareribs ~]# sed '/SELINUX/s/enforcing/disabled/g' /etc/selinux/config</span><br><span class="line">[root@spareribs ~]# init 6 </span><br><span class="line">[root@spareribs ~]# yum -y install etcd kubernetes      #会自动安装docker</span><br><span class="line">[root@spareribs ~]# systemctl restart etcd docker kube-apiserver kube-controller-manager kube-scheduler kubelet kube-proxy      #需要按顺序启动</span><br></pre></td></tr></table></figure><h4 id="查看服务端口"><a href="#查看服务端口" class="headerlink" title="查看服务端口"></a>查看服务端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep -E "kube|etcd|docker"</span><br><span class="line">netstat -tnlp | grep -E "kube|etcd|docker"</span><br></pre></td></tr></table></figure><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><h4 id="定义MySQL-RC文件"><a href="#定义MySQL-RC文件" class="headerlink" title="定义MySQL RC文件"></a>定义MySQL RC文件</h4><h5 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h5><ul><li>kind：资源对象类型，ReplicationController表示是一个RC</li><li>spec：RC的相关属性定义</li><li>spec.selector：表示是RC的Pod标签（Label）选择器，即监控和管理拥有这些标签的Pod实例，确保当前集群上始终有且仅有replicas个Pod实例在运行</li><li>spec.replicas：表示Pod实例运行的数量</li><li>spec.template：当Pod数量小于replicas时，RC会根据spec.template定义的Pod模板来生成新的Pod实例</li><li>spec.template.matadata.labels：指定该Pod的标签，必须匹配之前的spec.selector，否则RC每次创建的Pod都无法被selector识别，到时候会成为一个死循环</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat mysql-rc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">'123456'</span></span><br></pre></td></tr></table></figure><h5 id="文件详解"><a href="#文件详解" class="headerlink" title="文件详解"></a>文件详解</h5><ul><li>kind：副本控制器RC</li><li>metadata.name：RC的名称，全局唯一</li><li>spec.selector.app：符合目标的Pod拥有此标签</li><li>spec.replicas：Pod副本期待数目</li><li>spec.template：根据此模板创建Pod的实例</li><li>spec.template.matadata.labels：Pod实例拥有的标签，对应RC的selector</li><li>spec.template.spec.containers：Pod实例内容器定义部分</li><li>spec.template.spec.containers.name：容器名字</li><li>spec.template.spec.containers.images：对应的docker镜像</li><li>spec.template.spec.containers.ports.containersPort：容器对应的端口号</li><li>spec.template.spec.containers.ports.env：注入到容器内的环境变量</li></ul><h4 id="发布MySQL-RC文件到集群中"><a href="#发布MySQL-RC文件到集群中" class="headerlink" title="发布MySQL RC文件到集群中"></a>发布MySQL RC文件到集群中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# kubectl create -f mysql-rc.yaml</span><br><span class="line"> replicationcontroller "mysql" created</span><br></pre></td></tr></table></figure><h4 id="查询mysql-RC信息及mysql-Pod信息"><a href="#查询mysql-RC信息及mysql-Pod信息" class="headerlink" title="查询mysql RC信息及mysql Pod信息"></a>查询mysql RC信息及mysql Pod信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# kubectl get rc</span><br><span class="line">NAME      DESIRED   CURRENT   READY     AGE</span><br><span class="line">mysql     1         1         1         1h</span><br><span class="line"></span><br><span class="line">[root@k8s ~]# kubectl get pods</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">mysql-kl3bx   1/1       Running   0          1h</span><br></pre></td></tr></table></figure><h5 id="启动Pod失败解决方案"><a href="#启动Pod失败解决方案" class="headerlink" title="启动Pod失败解决方案"></a>启动Pod失败解决方案</h5><p>发现Pod一直处于ContainCreating状态，可以使用kubectl describe pod mysql查看报错信息</p><p>image pull failed for registry.access.redhat.com/rhel7/pod-infrastructure:latest, this may be because there are no credentials on this request.  details: (open /etc/docker/certs.d/registry.access.redhat.com/redhat-ca.crt: no such file or directory)</p><ul><li>yum install <em>rhsm</em> -y     #测试不生效</li><li>使用如下方式解决</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# wget http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm</span><br><span class="line">[root@k8s ~]# rpm2cpio python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm | cpio -iv --to-stdout ./etc/rhsm/ca/redhat-uep.pem | tee /etc/rhsm/ca/redhat-uep.pem</span><br></pre></td></tr></table></figure><p>Failed to create pod infra container: ImagePullBackOff; Skipping pod “redis-master-jj6jw_default(fec25a87-cdbe-11e7-ba32-525400cae48b)”: Back-off pulling image “registry.access.redhat.com/rhel7/pod-infrastructure:lates” </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# docker pull registry.access.redhat.com/rhel7/pod-infrastructure:latest</span><br></pre></td></tr></table></figure><ul><li>如果启动失败，需要先删除在创建</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# kubectl delete -f mysql-rc.yaml</span><br><span class="line">[root@k8s ~]# kubectl create -f mysql-rc.yaml</span><br><span class="line">[root@k8s ~]# kubectl get rc </span><br><span class="line">[root@k8s ~]# kubectl get pods</span><br></pre></td></tr></table></figure><h4 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h4><p>此时会发现MySQL Pod对应的容器还多创建了一个来自谷歌的pause容器，这个就是Pod的根容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# docker ps | grep mysql</span><br><span class="line">3488f858c29a        mysql                                                        "docker-entrypoint..."   About an hour ago   Up About an hour                        k8s_mysql.f6601b53_mysql-kl3bx_default_c3374963-b0c6-11e9-aca2-000c294094ee_89d776ee</span><br><span class="line">b5ac50286749        registry.access.redhat.com/rhel7/pod-infrastructure:latest   "/usr/bin/pod"           About an hour ago   Up About an hour                        k8s_POD.1d520ba5_mysql-kl3bx_default_c3374963-b0c6-11e9-aca2-000c294094ee_85e02244</span><br></pre></td></tr></table></figure><h4 id="定义一个Service文件"><a href="#定义一个Service文件" class="headerlink" title="定义一个Service文件"></a>定义一个Service文件</h4><h5 id="参数解释-1"><a href="#参数解释-1" class="headerlink" title="参数解释"></a>参数解释</h5><ul><li>metadata：是Service的服务名</li><li>spec.ports.port：定义了Service的虚拟端口</li><li>spec.selector：确定了那些Pod副本</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat mysql-svc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><h5 id="文件详解-1"><a href="#文件详解-1" class="headerlink" title="文件详解"></a>文件详解</h5><ul><li>kind：标明k8s Services</li><li>matadata.name：Service的全局唯一名称</li><li>spec.ports.port：Service提供服务的端口号</li><li>spec.selector：Service对应的Pod拥有这里定义的标签</li></ul><h4 id="发布MySQL-SVC文件到集群中"><a href="#发布MySQL-SVC文件到集群中" class="headerlink" title="发布MySQL SVC文件到集群中"></a>发布MySQL SVC文件到集群中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# kubectl create -f mysql-svc.yaml</span><br><span class="line">service "mysql" created</span><br></pre></td></tr></table></figure><h4 id="查询svc文件信息"><a href="#查询svc文件信息" class="headerlink" title="查询svc文件信息"></a>查询svc文件信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# kubectl get svc</span><br><span class="line">NAME         CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   10.254.0.1      &lt;none&gt;        443/TCP          2h</span><br><span class="line">mysql        10.254.202.48   &lt;none&gt;        3306/TCP         1h</span><br></pre></td></tr></table></figure><h3 id="启动Tomcat应用"><a href="#启动Tomcat应用" class="headerlink" title="启动Tomcat应用"></a>启动Tomcat应用</h3><h4 id="定义Tomcat-RC文件"><a href="#定义Tomcat-RC文件" class="headerlink" title="定义Tomcat RC文件"></a>定义Tomcat RC文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat myweb-rc.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line"><span class="attr">  name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span> </span><br><span class="line"><span class="attr">    app:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">  template:</span> </span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span> </span><br><span class="line"><span class="attr">        app:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">    spec:</span> </span><br><span class="line"><span class="attr">      containers:</span> </span><br><span class="line"><span class="attr">        - name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">kubeguide/tomcat-app:v1</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">          - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">          env:</span> </span><br><span class="line"><span class="attr">          - name:</span> <span class="string">MYSQL_SERVICE_HOST</span></span><br><span class="line"><span class="attr">            value:</span> <span class="number">10.254</span><span class="number">.202</span><span class="number">.48</span></span><br></pre></td></tr></table></figure><h4 id="发布Tomcat-RC文件到集群中"><a href="#发布Tomcat-RC文件到集群中" class="headerlink" title="发布Tomcat RC文件到集群中"></a>发布Tomcat RC文件到集群中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# kubectl create -f myweb-rc.yaml</span><br><span class="line">replicationcontroller "myweb" created</span><br></pre></td></tr></table></figure><h4 id="查询Tomcat-RC信息及Pod信息"><a href="#查询Tomcat-RC信息及Pod信息" class="headerlink" title="查询Tomcat RC信息及Pod信息"></a>查询Tomcat RC信息及Pod信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s k8s]# kubectl get rc    </span><br><span class="line">NAME      DESIRED   CURRENT   READY     AGE</span><br><span class="line">mysql     1         1         1         1h</span><br><span class="line">myweb     2         2         2         1h</span><br><span class="line"></span><br><span class="line">[root@k8s k8s]# kubectl get pod</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">mysql-kl3bx   1/1       Running   0          1h</span><br><span class="line">myweb-djvx5   1/1       Running   0          1h</span><br><span class="line">myweb-jcmz8   1/1       Running   0          1h</span><br></pre></td></tr></table></figure><h4 id="定义一个Service文件-1"><a href="#定义一个Service文件-1" class="headerlink" title="定义一个Service文件"></a>定义一个Service文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat myweb-svc.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30001</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myweb</span></span><br></pre></td></tr></table></figure><h4 id="发布Tomcat-SVC文件到集群中"><a href="#发布Tomcat-SVC文件到集群中" class="headerlink" title="发布Tomcat SVC文件到集群中"></a>发布Tomcat SVC文件到集群中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s ~]# kubectl create -f myweb-svc.yaml</span><br><span class="line">service "myweb" created</span><br></pre></td></tr></table></figure><h4 id="查看Tomcat-SVC信息"><a href="#查看Tomcat-SVC信息" class="headerlink" title="查看Tomcat SVC信息"></a>查看Tomcat SVC信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s k8s]# kubectl get svc</span><br><span class="line">NAME         CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   10.254.0.1      &lt;none&gt;        443/TCP          2h</span><br><span class="line">mysql        10.254.202.48   &lt;none&gt;        3306/TCP         1h</span><br><span class="line">myweb        10.254.128.72   &lt;nodes&gt;       8080:30001/TCP   1h</span><br><span class="line">[root@k8s k8s]#</span><br></pre></td></tr></table></figure><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><ul><li>使用curl 10.254.128.72 8080可以正常访问tomat</li><li>使用curl 172.16.100.11 30001却访问不了</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用该命令即可解决问题</span></span><br><span class="line">[root@k8s k8s]# iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用k8s部署一个Java WEB应用。该应用运行在Tomcat里的Web App。需要启动两个容器：WEB容器和MySQL容器，并且Web App需要访问MySQL容器。&lt;/p&gt;
&lt;h3 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="K8S" scheme="http://www.dookt.com/categories/K8S/"/>
    
    
      <category term="容器" scheme="http://www.dookt.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mysql设置权限</title>
    <link href="http://www.dookt.com/post/41380.html"/>
    <id>http://www.dookt.com/post/41380.html</id>
    <published>2019-07-26T14:25:22.000Z</published>
    <updated>2019-07-31T05:35:22.926Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL是由列级别权限存在的。实现了限制用户对表上特定列的访问权限。一般都是实现对表级别不具备访问权限，但是对某些列有访问权限。当然也存在其他情形。</p><h3 id="使用物理工具备份可能需要的权限"><a href="#使用物理工具备份可能需要的权限" class="headerlink" title="使用物理工具备份可能需要的权限"></a>使用物理工具备份可能需要的权限</h3><ul><li>物理备份工具：innobackupex，MySQL Enterprise Backup等等 </li><li>权限lock tables  作用：备份时锁表，产生一致性备份</li><li>权限process  作用：show processlist,show engine innodb status,查看线程，查看引擎状态</li><li>权限reload  作用：flush table/host/logs/tables/status/threads/refresh/reload，所有的flush操作。用于锁表，切割日志，更新权限</li><li>权限：replication client 作用：show master/slave status;查看事务日志执行状态与位置 show binary logs；查看当前保存的事务日志列表与文件大小</li><li>权限：super 作用：super权限很多很多，但是没有CURD（增删改查权限），这里点到为止说一下和备份相关的起停复制线程，切换主库位置，更改复制过滤条件，清理二进制日志，赋予账户视图与存储过程的DEFINER权限，创建链接服务器（类似于MSSQL的订阅服务器），关闭线程，不受最大连接线程数限制的VIP连接通道，阻断刷新线程的命令，不受离线模式影响，</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant lock tables,reload,process,replication client,super,select,event,trigger,show view on *.* to bak@'192.168.%';</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="使用逻辑备份工具可能需要的权限"><a href="#使用逻辑备份工具可能需要的权限" class="headerlink" title="使用逻辑备份工具可能需要的权限"></a>使用逻辑备份工具可能需要的权限</h3><ul><li>逻辑备份工具：mysqldump,mysqlpump,mydumper等等</li><li>权限SELECT  作用：查询表中数据</li><li>权限SHOW VIEW  作用：查看创建视图的语句 </li><li>权限TRIGGER  作用：备份触发器    </li><li>权限EVENT  作用：备份事件（定时任务） </li><li>权限lock tables  作用：备份时锁表，产生一致性备份    </li><li>权限reload  作用：show processlist,show engine innodb status,查看线程，查看引擎状态</li><li>权限replication client  作用：show master/slave status;查看事务日志执行状态与位置 show binary logs；查看当前保存的事务日志列表与文件大小</li><li>权限：super  作用：关闭线程，不受最大连接线程数限制的VIP连接通道，阻断刷新线程的命令，不受离线模式影响</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant lock tables,reload,process,replication client,super,select,event,trigger,show view on *.* to bak@'192.168.%';</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>super权限可以防止因为线程满，备份任务无法连接数据库而导致的备份翻车。且阻断刷新线程也是很重要</li><li>innobackupex主要以物理文件和备份缓存文件的方式进行，所以不需要show权限与select权限<br>逻辑备份的基本原理就是数据全部读取，必须select与show权限，查看表定义的权限由select权限提供</li><li>login-path的以port+host的方式保存时，会在用户目录下生成.login.cnf文件，拷贝到网络互通的其他主机上，仍然可以登陆，方便的同时也留下祸根</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL是由列级别权限存在的。实现了限制用户对表上特定列的访问权限。一般都是实现对表级别不具备访问权限，但是对某些列有访问权限。当然也存在其他情形。&lt;/p&gt;
&lt;h3 id=&quot;使用物理工具备份可能需要的权限&quot;&gt;&lt;a href=&quot;#使用物理工具备份可能需要的权限&quot; class
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.dookt.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.dookt.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker实战</title>
    <link href="http://www.dookt.com/post/11988.html"/>
    <id>http://www.dookt.com/post/11988.html</id>
    <published>2019-07-26T14:17:23.000Z</published>
    <updated>2019-07-27T11:08:30.039Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的linux机器上，也可以实现虚拟化。Docker虚拟化有三个概念需要理解，分别<strong>镜像、容器、仓库</strong>。</p><p>镜像：Docker的镜像其实就是模板，跟我们常见的ISO镜像类似，是一个样板。Docker镜像作为docker中最基本的概念，一个完整的Docker镜像可以支撑一个Docker容器的运行，在Docker容器运行过程中主要提供文件系统数据支撑。有以下几个特性：<br>    - 镜像分层，每个镜像都由一个或多个镜像层组成；<br>    - 可通过在某个镜像加上一定的镜像层得到新镜像（此过程可通过编写dockerfile或基于容器Commit实现）<br>    - 每个镜像层拥有唯一镜像ID<br>    - 镜像在存储和使用时共享相同的镜像层（根据ID），所以在pull镜像时，已有的镜像层会自动跳过下载；<br>    - 每个镜像层都是只读，即使启动成容器，也无法对其真正的修改，修改只会作用于最上层的容器层；<br>容器：使用镜像常见的应用或者系统，我们称之为一个容器。（通俗来说，镜像运行起来叫容器）<br>仓库：仓库是存放镜像的地方，分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p>注：以下环境全部基于Centos7.*</p><h3 id="安装docker引擎"><a href="#安装docker引擎" class="headerlink" title="安装docker引擎"></a>安装docker引擎</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docekr</span><br><span class="line">sed -i s/SELINUX/enforcing/disabled/g /etc/selinux/conf</span><br><span class="line">setenforce 0</span><br><span class="line">systemctl disable firewald </span><br><span class="line">systemctl stop firewalld</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker  version #查看版本</span><br><span class="line">docker  search centos#搜索可用docker镜像</span><br><span class="line">docker  images 查看当前docker所有镜像</span><br><span class="line">docker  pull  centos #下载镜像</span><br><span class="line">cat   centos.tar | docker import  -  centos6_newname  #Docker导入镜像</span><br><span class="line">docker  export  容器_id  &gt; cenos6.tar  #Docker导出镜像</span><br><span class="line">docker  run  centos  echo "hello word"#在docker容器中运行hello world!</span><br><span class="line">docker  run  centos  yum install ntpdate#在容器中安装ntpdate的程序</span><br><span class="line">docker  ps -l 命令获得最后一个容器的id，docker   ps  -a查看所有的容器。</span><br><span class="line">运行docker commit 提交刚修改的容器，例如：</span><br><span class="line">docker  commit  2313132  centos:v1</span><br><span class="line">docker run -i -t -d centos /bin/bash 在容器里启动一个/bin/bash shell环境，可以登录进入操作，其中-t tty，表示打开一个终端的意思，-i interactive，表示可以交互输入,-d表示在后台启动，以daemon方式启动。  </span><br><span class="line">docker  run  -d  centos:v1  /bin/bash </span><br><span class="line">Docker  stop  id 关闭容器</span><br><span class="line">Docker  start  id 启动某个容器</span><br><span class="line">docker  rm  id 删除容器，docker  rmi  images删除镜像</span><br><span class="line">docker  run  -d  -p  80:80  -p 8022:22   centos:v2，解析：-p指定容器启动后docker上运行的端口映射及容器里运行的端口，80:80，第一个80表示docker系统上的80，第二个80表示docker虚拟机里面的端口。用户默认访问本机80端口，自动映射到容器里面的80端口。</span><br><span class="line">docker  exec   -it  id  /bin/bash 进入容器终端</span><br><span class="line">docker  exec  id ifconfig查看容器的IP地址；</span><br><span class="line">Docker  inspect id |grep -i ipaddr查看容器IP地址；</span><br><span class="line">Docker  exec  df -h查看容器的磁盘分区信息</span><br></pre></td></tr></table></figure><h3 id="docker和docker-ce修改国内镜像源"><a href="#docker和docker-ce修改国内镜像源" class="headerlink" title="docker和docker-ce修改国内镜像源"></a>docker和docker-ce修改国内镜像源</h3><ul><li><p>docker配置国内镜像源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/docker/daemon.json </span><br><span class="line">&#123; </span><br><span class="line">"registry-mirrors": \["https://registry.docker-cn.com"\] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>docker-ce配置国内镜像源<br>编辑docker-ce启动脚本/usr/lib/systemd/system/docker.service，在ExecStart=/usr/bin/dockerd后添加docker仓库源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --registry-mirror=https://jxus37ad.mirror.aliyuncs.com</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li></ul><h3 id="docker网络模式"><a href="#docker网络模式" class="headerlink" title="docker网络模式"></a>docker网络模式</h3><p>基于docker run 创建Docker容器时，可以使用–net选项制定容器的网络模式，Docker默认四种网络模式：host、container、none、bridge（–net=host, –net=container ,  –net=none –net=bridge）</p><ul><li>host模式：Docker容器运行时，会默认分配独立的network Namespace，用于隔离子系统，基于host模式时，容器将不会获得独立的Network Namespace。将与宿主机共用一个Netework Namespace，不会配置IP地址，而是使用宿主机的IP地址</li><li>container模式：新创建的容器和已经存在的容器共享一个Network Namespace，而不是和宿主机共享，依赖与第一个存在的容器</li><li>none模式：容器拥有自己的Network Namespace，但是不对Docker 容器进行任何网路配置，也就是说该Docker容器没有网卡、IP、路由等信息，需要手工为Docker容器添加网卡、配置IP等，典型Pipework工具为Docker容器指定IP等信息；</li><li>bridge模式：Bridge模式是Docker默认的网络模式，该模式会为每一个容器分配Network Namespace、设置IP、路由等配置，默认会将Docker容器连接到一个虚拟网桥交换机Docker0上。</li></ul><ul><li>首先宿主机上创建一对虚拟网卡veth pair设备，veth设备总是成对出现的，组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来，veth设备常用来连接两个网络设备。</li><li>Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0，然后将另一端放在宿主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。</li><li>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</li><li>此时容器IP与宿主机能够通信，宿主机也可以访问容器中的IP地址，在Bridge模式下，连在同一网桥上的容器之间可以相互通信，同时容器也可以访问外网，但是其他物理机不能访问docker容器IP，需要通过NAT将容器IP的port映射为宿主机的IP和port。</li></ul><h3 id="docker配置bridge网络"><a href="#docker配置bridge网络" class="headerlink" title="docker配置bridge网络"></a>docker配置bridge网络</h3><p>Centos7下docker使用桥接模式非常简单，当然我们借助 大牛 写的pipework工具实现</p><ul><li>安装pipework工具</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jpetazzo/pipework /usr/local/pipework</span><br><span class="line">cp ~/pipework/pipework /usr/local/bin/</span><br></pre></td></tr></table></figure><ul><li>启动一个docker容器<ul><li>注意一定要加上–net=none（分配网络空间但不配置IP地址）</li><li>docker run -itd –net=none nginx          #启动一个Nginx容器</li></ul></li><li>使用pipework配置桥接网络<ul><li>docker ps -a             #查看刚刚启动的Nginx的容器ID</li><li># “677dd7beac02”为Nginx的容器ID，以此为IP地址、掩码、网关。注意网关一定是docker宿主机的IP地址</li><li>pipework br0 677dd7beac02 192.168.2.103/24@192.168.2.253</li></ul></li></ul><h3 id="Dockerfile实战"><a href="#Dockerfile实战" class="headerlink" title="Dockerfile实战"></a>Dockerfile实战</h3><p>由于Docker官网公共仓库镜像大多不完整，无法真正满足企业的生产环境系统，此时需要我们自行定制镜像或者重新打包镜像。<br>Docker镜像制作是管理员的必备工作之一，Docker镜像制作的方法主要有两种，制作方法如下：<br>Docker commit|export将新容器提交至Images列表；<br>编写Dockerfile，bulid新的镜像至镜像列表；</p><p>本例，基础镜像采用 docker.io/lemonbar/centos6-ssh</p><ul><li>运行一个基础镜像来启动一个容器，修改相应配置，并使用docker commit提交</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd docker.io/lemonbar/centos6-ssh       #启动镜像</span><br><span class="line">docker exec -it 44b3fb717f9f /bin/bash          #进去刚启动的容器中</span><br><span class="line">rm /etc/yum.repos.d/*.repo;wget -c http://mirrors.aliyun.com/repo/Centos-6.repo  # 在容器中中执行，更换阿里云镜像源</span><br><span class="line">docker commit 44b3fb717f9f centos-test:v1        #在宿主机上提交</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">- 根据需求编写Dockerfile文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##生成nginx镜像</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置基本镜像</span></span><br><span class="line">FROM centos-test:v1</span><br><span class="line"><span class="meta">#</span><span class="bash">作者信息</span></span><br><span class="line">MAINTAINER MINT</span><br><span class="line"><span class="meta">#</span><span class="bash">设置工作目录</span></span><br><span class="line">WORKDIR /root</span><br><span class="line">RUN cp /etc/skel/.bash* /root</span><br><span class="line">RUN echo '123456'|passwd --stdin root</span><br><span class="line">RUN rpm --rebuilddb &amp;&amp; yum -y install tar vim wget gcc gcc-c++ make pcre pcre-devel zlib zlib-devel gzip* bzip* net-tools ntpdate</span><br><span class="line">RUN wget -c http://nginx.org/download/nginx-1.12.2.tar.gz;tar -xf nginx-1.12.2.tar.gz;cd nginx-1.12.2;./configure --prefix=/usr/local/nginx &amp;&amp; make &amp;&amp; make install</span><br><span class="line"><span class="meta">#</span><span class="bash">暴露端口</span></span><br><span class="line">EXPOSE 22 80</span><br><span class="line"><span class="meta">#</span><span class="bash">设置运行镜像时的默认命令</span></span><br><span class="line">CMD /usr/local/nginx/sbin/nginx; /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##生成redis镜像</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置基本镜像</span></span><br><span class="line">FROM centos-test:v2</span><br><span class="line"><span class="meta">#</span><span class="bash">作者信息</span></span><br><span class="line">MAINTAINER  MINT</span><br><span class="line"><span class="meta">#</span><span class="bash">设置工作目录</span></span><br><span class="line">WORKDIR /root</span><br><span class="line">RUN cp /etc/skel/.bash* /root</span><br><span class="line">RUN echo '123456'|passwd --stdin root</span><br><span class="line">RUN rpm --rebuilddb &amp;&amp; yum -y install wget tar gcc gcc-c++ make</span><br><span class="line">RUN tar -xf redis-4.0.10.tar.gz;cd redis-4.0.10;make PREFIX=/usr/local/redis install</span><br><span class="line"><span class="meta">#</span><span class="bash">暴露端口</span></span><br><span class="line">EXPOSE 22 6379</span><br><span class="line"><span class="meta">#</span><span class="bash">设置运行镜像时的默认命令</span></span><br><span class="line">CMD /usr/local/redis/bin/redis-server; /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure><ul><li>使用docker build 生成新镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t centos-nginx .               </span><br><span class="line">docker build -t centos-redis -f /root/Docker-redis         #指定redis的dockerfile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的linux机器上，也可以实现虚拟化。Docker虚拟化有三个概念需要理解，分别&lt;strong&gt;镜像、容器、仓库&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;镜像：Do
      
    
    </summary>
    
      <category term="Docker" scheme="http://www.dookt.com/categories/Docker/"/>
    
    
      <category term="虚拟化" scheme="http://www.dookt.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Mycat+MySQL读写分离</title>
    <link href="http://www.dookt.com/post/35152.html"/>
    <id>http://www.dookt.com/post/35152.html</id>
    <published>2019-07-26T14:03:59.000Z</published>
    <updated>2019-07-31T05:21:07.215Z</updated>
    
    <content type="html"><![CDATA[<p>随着互联网时代的发展，传统的数据库技术日趋成熟、计算机网络技术的飞速发展和应用范围的扩充，数据库应用已经普遍建立于计算机网络之上。此时集中式数据库系统表现出它的不足：</p><ul><li>集中式处理，势必造成性能瓶颈；</li><li>应用程序集中在一台计算机上运行，一旦该计算机发生故障，则整个系统受到影响，可靠性不高；</li><li>集中式处理引起系统的规模和配置都不够灵活，系统的可扩充性差。</li></ul><p>在这种形势下，集中式数据库将向分布式数据库发展。</p><h3 id="MyCAT发展历程"><a href="#MyCAT发展历程" class="headerlink" title="MyCAT发展历程"></a>MyCAT发展历程</h3><hr><p>MyCAT的诞生，要从其前身Amoeba和Cobar说起，Amoeba（变形虫）项目，该开源框架于2008年开始发布一款 Amoeba for Mysql软件。这个软件致力于MySQL的分布式数据库前端代理层，它主要在应用层访问MySQL的时候充当SQL路由功能，专注于分布式数据库代理层（Database Proxy）开发。</p><p>座落与 Client、DB Server(s)之间，对客户端透明。具有负载均衡、高可用性、SQL过滤、读写分离、可路由相关的到目标数据库、可并发请求多台数据库合并结果。 通过Amoeba你能够完成多数据源的高可用、负载均衡、数据切片的功能，目前Amoeba已在很多企业的生产线上面使用。</p><p>阿里巴巴于2012年6月19日，正式对外开源的数据库中间件Cobar，前身是早已经开源的Amoeba，不过其作者陈思儒离职去盛大之后，阿里巴巴内部考虑到Amoeba的稳定性、性能和功能支持，以及其他因素，重新设立了一个项目组并且更换名称为Cobar。[Cobar](<a href="https://github.com/alibaba/cobar&quot;" target="_blank" rel="noopener">https://github.com/alibaba/cobar&quot;</a> \t “_blank) 是由 Alibaba 开源的 MySQL 分布式处理中间件，它可以在分布式的环境下看上去像传统数据库一样提供海量数据服务。</p><p>Cobar自诞生之日起， 就受到广大程序员的追捧，但是自2013年后，几乎没有后续更新。在此情况下，MyCAT应运而生，它基于阿里开源的Cobar产品而研发，Cobar的稳定性、可靠性、优秀的架构和性能，以及众多成熟的使用案例使得MyCAT一开始就拥有一个很好的起点，站在巨人的肩膀上，MyCAT能看到更远。目前MyCAT的最新发布版本为1.6版本。</p><p>从定义和分类来看，MyCAT是一个开源的分布式数据库系统，是一个实现了MySQL协议的Server，前端用户可以把它看做是一个数据库代理中间件，基于MySQL客户端工具和命令行访问，其后端可以用MySQL原生（Native）协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信，其核心功能是分库分表，即将一个大表水平分割为N个小表，存储在后端MySQL服务器里或者其他数据库里。</p><p>Mycat发展到目前版本，已经不在是一个单纯的MySQL代理，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL等主流数据库，也支持MongoDB这种新型NOSQL方式的存储，未来还会支持更多类型的存储。</p><p>最终用户看来，无论是那种存储方式，在Mycat里，都是一个传统的数据库表，支持标准的SQL语句进行数据的操作，对前端业务系统来说，可以大幅度降低开发难度，提升开发速度，在测试阶段，可以将一表定义为任何一种Mycat支持的存储方式，比如MySQL的MyASM表、内存表、或者MongoDB、LeveIDB以及号称是世界上最快的内存数据库MemSQL上。</p><h4 id="DBA眼中的MyCAT"><a href="#DBA眼中的MyCAT" class="headerlink" title="DBA眼中的MyCAT"></a><strong>DBA眼中的MyCAT</strong></h4><p>Mycat就是MySQL Server，而Mycat后面连接的MySQL Server，就好象是MySQL的存储引擎,如InnoDB，MyISAM等，因此，Mycat本身并不存储数据，数据是在后端的MySQL上存储的，因此数据可靠性以及事务等都是MySQL保证的，简单的说，Mycat就是MySQL最佳伴侣，它在一定程度上让MySQL拥有了能跟Oracle PK的能力。</p><h4 id="软件工程师眼中的MyCAT"><a href="#软件工程师眼中的MyCAT" class="headerlink" title="软件工程师眼中的MyCAT"></a><strong>软件工程师眼中的MyCAT</strong></h4><p>Mycat就是一个近似等于MySQL的数据库服务器，你可以用连接MySQL的方式去连接Mycat（除了端口不同，默认的Mycat端口是8066而非MySQL的3306，因此需要在连接字符串上增加端口信息），大多数情况下，可以用你熟悉的对象映射框架使用Mycat，但建议对于分片表，尽量使用基础的SQL语句，因为这样能达到最佳性能，特别是几千万甚至几百亿条记录的情况下。</p><h4 id="架构师眼中的MyCAT"><a href="#架构师眼中的MyCAT" class="headerlink" title="架构师眼中的MyCAT"></a><strong>架构师眼中的MyCAT</strong></h4><p>Mycat是一个强大的数据库中间件，不仅仅可以用作读写分离、以及分表分库、容灾备份，而且可以用于多租户应用开发、云平台基础设施、让你的架构具备很强的适应性和灵活性，借助于即将发布的Mycat智能优化模块，系统的数据访问瓶颈和热点一目了然，根据这些统计分析数据，你可以自动或手工调整后端存储，将不同的表映射到不同存储引擎上，而整个应用的代码一行也不用改变。</p><h3 id="MyCAT中间件原理"><a href="#MyCAT中间件原理" class="headerlink" title="MyCAT中间件原理"></a>MyCAT中间件原理</h3><hr><p>Mycat的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的SQL语句，首先对SQL语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。</p><p>Orders表被分为三个分片datanode（简称dn)，这三个分片是分布在两台MySQL Server上(DataHost)，即datanode=database@datahost方式，因此你可以用一台到N台服务器来分片，分片规则为（sharding rule)典型的字符串枚举分片规则，一个规则的定义是分片字段（sharding column)+分片函数(rule function)，这里的分片字段为rov而分片函数为字符串枚举方式。</p><p>当Mycat收到一个SQL时，会先解析这个SQL，查找涉及到的表，然后看此表的定义，如果有分片规则，则获取到SQL里分片字段的值，并匹配分片函数，得到该QL对应的分片列表，然后将SQL发往这些分片去执行，最后收集和处理所有分片返回的结果数据，并输出到客户端。</p><p>以select * from Orders where prov=?语句为例，查到prov=wuhan，按照分片函数，wuhan返回dn1，于是SQL就发给了MySQL1，去取DB1上的查询结果，并返回给用户。</p><p>如果上述SQL改为elect * from Orders where prov in (‘wuhan’,‘beijing’)，那么，SQL就会发给ySQL1与MySQL2去执行，然后结果集合并后输出给用户。</p><p>通常业务中我们的SQL会有Order By 以及Limit翻页语法，此时就涉及到结果集在Mycat端的二次处理，这部分的代码也比较复杂，而最复杂的则属两个表的Jion问题，为此，Mycat提出了创新性的ER分片、全局表、HBT（Human Brain Tech)人工智能的Catlet、以及结合Storm/Spark引擎等十八般武艺的解决办法，从而成为目前业界最强大的方案，这就是开源的力量。</p><h3 id="MyCAT应用场景"><a href="#MyCAT应用场景" class="headerlink" title="MyCAT应用场景"></a>MyCAT应用场景</h3><hr><p>Mycat发展到现在，适用的场景已经很丰富，而且不断有新用户给出新的创新性的方案，以下是几个典型的应用场景：</p><ul><li>单纯的读写分离，此时配置最为简单，支持读写分离，主从切换；</li><li>分表分库，对于超过1000万的表进行分片，最大支持1000亿的单表分片；</li><li>多租户应用，每个应用一个库，但应用程序只连接Mycat,从而不改造程序本身，实现多租户化；</li><li>报表系统，借助于Mycat的分表能力，处理大规模报表的统计；</li><li>代替Hbase,分析大数据；</li><li>作为海量数据实时查询的一种简单有效方案，比如 1〇〇亿条频繁查询的记录需要在3秒内查询出来结果，除了基于主键的查询，还可能存在范围查询或其他属性查询，此时Mycat可能是最简单有效的选择；</li><li>单纯的MyCAT读写分离，配置最为简单，支持读写分离，主从切换分表分库，对于超过1000万的表进行分片，最大支持1000亿的单表分片；</li><li>多租户应用，每个应用一个库，但应用程序只连接Mycat，从而不改造程序本身，实现多租户化；</li><li>报表系统，借助于Mycat的分表能力，处理大规模报表的统计替代Hbase，分析大数据，作为海量数据实时查询的一种简单有效方案，比如100亿条频繁查询的记录需要在3秒内查询出来结果，除了基于主键的查询，还可能存在范围查询或其他属性查询，此时Mycat可能是最简单有效的选择  。</li></ul><h2 id="Mycat概念详解"><a href="#Mycat概念详解" class="headerlink" title="Mycat概念详解"></a>Mycat概念详解</h2><p>Mycat是一个开源的分布式数据库系统，但是由于真正的数据库需要存储引擎，而Mycat并没有存储引擎，所以并不是完全意义的分布式数据库系统。</p><h4 id="MyCAT数据库中间件"><a href="#MyCAT数据库中间件" class="headerlink" title="MyCAT数据库中间件"></a>MyCAT数据库中间件</h4><p>那么Mycat是什么？Mycat是数据库中间件，就是介于数据库与应用之间，进行数据处理与交互的中间服务。对数据进行分片处理之后，从原有的一个库，被切分为多个分片数据库，所有的分片数据库集群构成了整个完整的数据库存储。</p><p>数据被分到多个分片数据库后，应用如果需要读取数据，就要需要处理多个数据源的数据。如果没有数据库中间件，那么应用将直接面对分片集群，数据源切换、事务处理、数据聚合都需要应用直接处理，原本该是专注于业务的应用，将会花大量的工作来处理分片后的问题，最重要的是每个应用处理将是完全的重复造轮子。</p><p>加入数据库中间件之后，应用只需要集中与业务处理，大量的通用的数据聚合，事务，数据源切换都由中间件来处理，中间件的性能与处理能力将直接决定应用的读写性能，所以一款好的数据库中间件至关重要。</p><h4 id="MyCAT逻辑库-schema"><a href="#MyCAT逻辑库-schema" class="headerlink" title="MyCAT逻辑库(schema)"></a>MyCAT逻辑库(schema)</h4><p>通常对实际应用来说，并不需要知道中间件的存在，开发人员只需要知道数据库的概念，所以数据库中间件可以被看做是一个或多个数据库集群构成的逻辑库。</p><p>在云计算时代，数据库中间件可以以多租户的形式给一个或多个应用提供服务，每个应用访问的可能是一个独立或者是共享的物理库，常见的如阿里云数据库服务器RDS。</p><h4 id="MyCAT逻辑表（Table"><a href="#MyCAT逻辑表（Table" class="headerlink" title="MyCAT逻辑表（Table)"></a>MyCAT逻辑表（Table)</h4><p>MyCAT既然有逻辑库，那么就会有逻辑表，分布式数据库中，对应用来说，读写数据的表就是逻辑表。逻辑表，可 以是数据切分后，分布在一个或多个分片库中，也可以不做数据切分，不分片，只有一个表构成。</p><h4 id="MyCAT分片表"><a href="#MyCAT分片表" class="headerlink" title="MyCAT分片表"></a>MyCAT分片表</h4><p>MyCAT分片表，是指那些原有的很大数据的表，需要切分到多个数据库的表，这样，每个分片都有一部分数据，所有分片构成了完整的数据；</p><p>例如在Mycat配置中的t_node就属于分片表，数据按照规则被分到dn1,dn2两个分片节点(dataNode) 上。</p><h4 id="MyCAT非分片表"><a href="#MyCAT非分片表" class="headerlink" title="MyCAT非分片表"></a>MyCAT非分片表</h4><p>如果一个数据库中并不是所有的表都很大，某些表是可以不用进行切分的，非分片是相对分片表来说的，就是那些不需要进行数据切分的表。如下配置中t_node ,只存在于分片节点（dataNode ) dn1上。</p><h4 id="MyCAT-ER表"><a href="#MyCAT-ER表" class="headerlink" title="MyCAT ER表"></a>MyCAT ER表</h4><p>关系型数据库是基于实体关系模型（Entity-Relationship Model)之上，通过其描述了真实世界中事物与关 系，Mycat中的ER表即是来源于此，根据这一思路，提出了基于E-R关系的数捤分片策略，子表的记录与所关 联的父表记录存放在同一个数据分片上，即子表依赖于父表，通过表分组（Table Group )保证数据Join不会跨库操作。</p><p>表分组（Table Group )是解决跨分片数据join的一种很好的思路，也是数据切分规划的重要一条规则。</p><h4 id="MyCAT全局表"><a href="#MyCAT全局表" class="headerlink" title="MyCAT全局表"></a>MyCAT全局表</h4><p>一个真实的业务系统中，往往存在大量的类似字典表的表，这些表基本上很少变动，字典表具有以下几个特性：</p><ul><li>变动不频繁；</li><li>数据量总体变化不大；</li><li>数据规模不大，很少有超过数十万条记录；</li></ul><h4 id="分片节点-dataNode"><a href="#分片节点-dataNode" class="headerlink" title="分片节点(dataNode)"></a>分片节点(dataNode)</h4><p>MyCAT数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点 (dataNode )。</p><h4 id="节点主机-dataHost"><a href="#节点主机-dataHost" class="headerlink" title="节点主机(dataHost)"></a>节点主机(dataHost)</h4><p>MyCAT数据切分后，每个分片节点（dataNode )不一定都会独占一台机器，同一机器上面可以有多个分片数据库， 这样一个或多个分片节点（dataNode )所在的机器就是节点主机（dataHost),为了规避单节点主机并发数限 制，尽量将读写压力高的分片节点（dataNode )均衡的放在不同的节点主机（dataHost )。</p><h4 id="分片规则-rule"><a href="#分片规则-rule" class="headerlink" title="分片规则(rule)"></a>分片规则(rule)</h4><p>MyCAT数据切分，1个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到 某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难度。</p><h4 id="MyCAT多租户"><a href="#MyCAT多租户" class="headerlink" title="MyCAT多租户"></a>MyCAT多租户</h4><p>多租户技术或称多重租赁技术，是一种软件架构技术，它是在探讨与实现如何于多用户的环境下共用相同的系统或程序组件，并且仍可确保各用户间数据的隔离性。</p><p>在云计算时代，多租户技术在共用的数据中心以单一系统架构与服务提供多数客户端相同甚至可定制化的服务，并且仍然可以保障客户的数据隔离。</p><p>目前各种各样的云计算服务就是这类技术范畴，例如阿里云数据库服务（RDS )、阿里云服务器(ECS)等等。</p><h2 id="数据多租户方案"><a href="#数据多租户方案" class="headerlink" title="数据多租户方案"></a>数据多租户方案</h2><p>目前互联网多租户在数据存储上存在三种主要的方案，独立数据库、共享数据库及共享数据库共享架构；</p><h4 id="独立数据库"><a href="#独立数据库" class="headerlink" title="独立数据库"></a>独立数据库</h4><p>多租户第一种方案，即一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本也高。</p><ul><li>该方案优点：<ul><li>为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；</li><li>如果出现故障，恢复数据比较简单。-</li></ul></li><li>该方案缺点：<ul><li>增大了数据库的安装数量；</li><li>数据库维护成本和购置成本的增加。</li></ul></li></ul><p>这种方案与传统的一个客户、一套数据、一套部署类似，差别只在于软件统一部署在运营商那里。如果面对的是银行、医院等需要非常高数据隔离级别的租户，可以选择这种模式，提高租用的定价。如果定价较低，产品 走低价路线，这种方案一般对运营商来说是无法承受的。</p><h4 id="共享数据库，隔离数据架构"><a href="#共享数据库，隔离数据架构" class="headerlink" title="共享数据库，隔离数据架构"></a>共享数据库，隔离数据架构</h4><p>多租户第二种方案，即多个或所有租户共享Database，但是每个租户一个Schema。</p><ul><li>该方案优点：<ul><li>为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；</li><li>每个数据库可以支持更多的租户数量。</li></ul></li><li>该方案缺点：<ul><li>如果出现故障，数据恢复比较困难，因为恢复数据库将牵扯到其它租户的数据；</li><li>如果需要跨租户统计数据，存在一定困难。</li></ul></li></ul><h4 id="共享数据库，共享数据架构"><a href="#共享数据库，共享数据架构" class="headerlink" title="共享数据库，共享数据架构"></a>共享数据库，共享数据架构</h4><p>多租户第三种方案，即租户共享同一个Database、同一个Schema，但在表中通过TenantID区分租户的数据，这是共享程度最高、隔离级别最低的模式。</p><ul><li><p>该方案优点：</p><ul><li>三种方案比较，第三种方案的维护和购置成本最低；</li><li>允许每个数据库支持的租户数量最多。</li></ul></li><li><p>该方案缺点：</p><ul><li>隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；</li><li>数据备份和恢复最困难，需要逐表逐条备份和还原。</li><li>如果希望以最少的服务器为最多的租户提供服务，并且租户接受以牺牲隔离级别换取降低成本，这种方案最适合；</li></ul></li></ul><h2 id="MyCAT数据切分"><a href="#MyCAT数据切分" class="headerlink" title="MyCAT数据切分"></a>MyCAT数据切分</h2><p>简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主 机）上面，以达到分散单台设备负载的效果。数据的切分(Sharding )根据其切分规则的类型，可以分为两种切分模式：</p><ul><li><p>按照不同的表（或者 Schema )来切分到不同的数据库(主机）之上，这种切可以称之为数据的垂直（纵向）切分；</p></li><li><p>根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称之为数据的水平（横向）切分。</p></li><li><p><strong>垂直切分</strong>的最大特点就是规则简单，实施也更为方便，尤其适合各业务之间的耦合度非常低，相互影响很小，业务逻辑非常清晰的系统。在这种系统中，可以很容易做到将不同业务模块所使用的表分拆到不同的数据库中。根据不同的表来进行拆分，对应用程序的影响也更小，拆分规则也会比较简单清晰。</p></li><li><p><strong>水平切分</strong>于垂直切分相比，相对来说稍微复杂一些。因为要将同一个表中的不同数据拆分到不同的据库中，对于应用程序来说，拆分规则本身就较根据表名来拆分更为复杂，后期的数据维护也会更为复杂一些。</p></li></ul><h4 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h4><p>数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同 的数据库上面，这样也就将数据或者说压力分担到不同的库上面，</p><p>一个架构设计较好的应用系统，其总体功能肯定是由很多个功能模块所组成的，而每一个功能模块所需要的 数据对应到数据库中就是一个或者多个表。而在架构设计中，各个功能模块相互之间的交互点越统一越少，系统 的耦合度就越低，系统各个模块的维护性以及扩展性也就越好。这样的系统，实现数据的垂直切分也就越容易。</p><p>往往系统之有些表难以做到完全的独立，存在这扩库join的情况，对于这类的表，就需要去做平衡，是数据库让步业务，共用一个数据源，还是分成多个库，业务之间通过接口来做调用。在系统初期，数据量比较少，或者资源有限的情况下，会选择共用数据源，但是当数据发展到了一定的规模，负载很大的情况，就需要必须去做分割。</p><p>一般来讲业务存在着复杂join的场景是难以切分的，往往业务独立的易于切分。如何切分，切分到何种 程度是考验技术架构的一个难题。</p><ul><li>垂直切分的优点：<ul><li>拆分后业务清晰，拆分规则明确；</li><li>系统之间整合或扩展容易；</li><li>数据维护简单。</li></ul></li><li>垂直切分的缺点：<ul><li>部分业务表无法join ,只能通过接口方式解决，提高了系统复杂度；</li><li>受每种业务不同的限制存在单库性能瓶颈，不易扩展跟性能提高。</li><li>事务处理复杂。由于垂直切分是按照业务的分类将表分散到不同的库，所以有些业务表会过于庞大，存在单库读写与存储瓶颈，所以就需要水平拆分来做解决。</li></ul></li></ul><h4 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h4><p>相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分 到一个数据库，而另外的某些行又切分到其他的数据库中，如图：</p><p>拆分数据就需要定义分片规则。关系型数据库是行列的二维模型，拆分的第一原则是找到拆分维度。比如: 从会员的角度来分析，商户订单交易类系统中查询会员某天期某个订单，那么就需要按照会员结合日期来拆分，不同的数据按照会员ID做分组，这样所有的数据查询join都会在单库内解决；</p><p>如果从商户的角度来讲，要查询某个商家某天所有的订单数，就需要按照商户ID做拆分；但是如果系统既想按会员拆分，又想按商家数据，则会有一定的困难。如何找到合适的分片规则需要综合考虑衡量。</p><h4 id="典型的分片规则"><a href="#典型的分片规则" class="headerlink" title="典型的分片规则"></a>典型的分片规则</h4><ul><li>按照用户ID求模，将数据分散到不同的数据库，具有相同数据用户的数据都被分散一个库中；</li><li>按照日期，将不同月甚至日的数据分散到不同的库中；</li><li>按照某个特定的字段求模，或者根据特定范围段分散到不同的库中。</li></ul><p>如图，切分原则都是根据业务找到适合的切分规则分散到不同的库，下面用用户 ID 求模举例：</p><p>既然数据做了拆分有优点也就优缺点。</p><ul><li><p>数据库拆分优点：</p><ul><li>拆分规则抽象好，join 操作基本可以数据库做；</li><li>不存在单库大数据，高并发的性能瓶颈；</li><li>应用端改造较少；</li><li>提高了系统的稳定性跟负载能力。</li></ul></li><li><p>数据库拆分缺点：</p><ul><li>拆分规则难以抽象；</li><li>分片亊务一致性难以解决；</li><li>数捤多次扩展难度跟维护量极大；</li><li>跨库 join 性能较差。</li></ul></li><li><p>垂直切分、水平切分共同的缺点：</p><ul><li>引入分布式亊务的问题；</li><li>跨节点 Join 的问题；</li><li>跨节点合并排序分页问题；</li><li>多数据源管理问题；</li></ul></li></ul><h4 id="针对数据源管理，目前主要有两种思路："><a href="#针对数据源管理，目前主要有两种思路：" class="headerlink" title="针对数据源管理，目前主要有两种思路："></a>针对数据源管理，目前主要有两种思路：</h4><ul><li>客户端模式，在每个应用程序模块中配置管理自己需要的一个（或者多个）数据源，直接访问各个数据库，在模块内完成数据的整合；</li><li>通过中间代理层来统一管理所有的数据源，后端数据库集群对前端应用程序透明，可能 90%以上的人在面对上面这两种解决思路的时候都会倾向于选择第二种，尤其是系统不断变得庞大复杂的时候。确实，这是一个非常正确的选择，虽然短期内需要付出的成本可能会相对更大一些，但是对整个系统的扩展性来讲，是非常有帮助的数据切分的原则：</li></ul><h4 id="数据切分的原则："><a href="#数据切分的原则：" class="headerlink" title="数据切分的原则："></a>数据切分的原则：</h4><ul><li>能不切分尽量不要切分；</li><li>如果要切分一定要选择合适的切分规则，提前规划好；  </li><li>数据切分尽量通过数据冗余或者表分组（Table Group）来降低跨库 Join 的可能；</li><li>由于数据库中间件对数据 Join 实现的优劣难以把握，而且实现高性能难度极大，业务读取尽量少使用多表 Join。</li></ul><h3 id="MyCAT安装配置"><a href="#MyCAT安装配置" class="headerlink" title="MyCAT安装配置"></a>MyCAT安装配置</h3><hr><h4 id="MyCAT系统安装环境："><a href="#MyCAT系统安装环境：" class="headerlink" title="MyCAT系统安装环境："></a>MyCAT系统安装环境：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.149.128 MyCAT</span><br><span class="line">192.168.149.129 MYSQL-MASTER</span><br><span class="line">192.168.149.130 MYSQL-SLAVE</span><br></pre></td></tr></table></figure><p>MyCAT安装之前，需要先安装jdk (Java Development Kit) ，JDK是 Java 语言的软件开发工具包(SDK)），本文安装版本为：jdk1.7.0_75.tar.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf jdk1.7.0_75.tar.gz</span><br><span class="line">mkdir -p /usr/java/</span><br><span class="line">mv jdk1.7.0_75 /usr/java/</span><br></pre></td></tr></table></figure><p>配置java环境变量，vi /etc/profile 添加如下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JAVA\_HOME=/usr/java/jdk1.7.0\_75</span><br><span class="line">export CLASSPATH=$CLASSPATH:$JAVA\_HOME/lib:$JAVA\_HOME/jre/lib</span><br><span class="line">export PATH=$JAVA\_HOME/bin:$JAVA\_HOME/jre/bin:$PATH:$HOMR/bin</span><br><span class="line">source /etc/profile //使环境变量立刻生效。</span><br><span class="line">java -version //查看java版本，显示版本为1.7.0_75，证明安装成功。</span><br></pre></td></tr></table></figure><p>官网下载MyCAT最新稳定版本1.6：<a href="http://www.mycat.io" target="_blank" rel="noopener">http://www.mycat.io</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.mycat.io/1.6-RELEASE/Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz</span><br><span class="line">tar xzf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz</span><br><span class="line">mv mycat/ /usr/local/</span><br></pre></td></tr></table></figure><p>进入MyCAT主目录，如图所示：</p><p>MyCAT配置目录详解如下：</p><ul><li>bin程序目录，存放了 window版本和linux版本启动脚本，除了提供封装服务的版本之外，也提供了 nowrap的 shell脚本命令，方便大家选择和修改，进入到bin目录：</li><li>Linux 下运行：./mycat console,首先要 chmod +x *</li><li>mycat 支持的命令{ console | start | stop | restart | status | dump }</li><li>conf目录下存放配置文件，其中：</li><li>server.xm 丨Mycat服务器参数调整和用户授权的配置文件；</li><li>schema.xm丨逻辑库定义和表及分片定义的配置文件；</li><li>rule.xml |分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改，需要重启Mycat或者通过9066端口 reload；</li><li>lib目录下主要存放mycat依赖的一些jar文件；</li><li>日志存放在logs/mycat.log中，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要，可以调整输出级别为debug , debug级别下；</li><li>Catlet |支持跨分片复杂SQL实现以及存储过程支持。</li></ul><p>本文基于MyCAT实现读写分离，只需要涉及到两个MyCAT配置文件，分别是：server.xml和schema.xml文件：<br>其中Server.xml文件主要配置段内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"jfedu1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>jfedu1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>testdb<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"jfedu2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>jfedu2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>testdb<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readOnly"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建jfedu1、jfedu2两个用户用于连接MyCAT中间件：</li><li>用户名jfedu1、密码jfedu1，对逻辑数据库testdb具有增删改查的权限，也即WEB连接MyCAT的用户名和密码；</li><li>用户名jfedu2，密码jfedu2，该用户对逻辑数据库testdb只读的权限；</li></ul><p>其中Schema.xml文件主要配置内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"testdb"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"1000"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"discuz"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"localhost1"</span> <span class="attr">maxCon</span>=<span class="string">"2000"</span> <span class="attr">minCon</span>=<span class="string">"1"</span> <span class="attr">balance</span>=<span class="string">"0"</span> <span class="attr">writeType</span>=<span class="string">"1"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span> <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.149.129:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.149.130:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上配置逻辑数据库testdb必须和server.xml中的用户指定的testdb数据库名称一致，否则会报错！如下为配置文件详解：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">xml文件格式；</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;</span><br><span class="line">文件标签属性；</span><br><span class="line">&lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt;</span><br><span class="line">Mycat起始标签</span><br><span class="line">&lt;schema name="testdb" checkSQLschema="false" sqlMaxLimit="1000" dataNode="dn1"&gt;</span><br><span class="line">&lt;/schema&gt;</span><br></pre></td></tr></table></figure><p>配置逻辑库，与server.xml指定库名保持一致，绑定数据节点dn1;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"discuz"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>添加数据节点dn1，设置数据节点host名称，同时设置数据节点真实database为discuz；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"localhost1"</span> <span class="attr">maxCon</span>=<span class="string">"2000"</span> <span class="attr">minCon</span>=<span class="string">"1"</span> <span class="attr">balance</span>=<span class="string">"0"</span> <span class="attr">writeType</span>=<span class="string">"1"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span> <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据节点主机，绑定数据节点，设置连接数及均衡方式、切换方法、驱动程序、连接方法；</p><p><strong>Balance均衡策略设置：</strong></p><ol><li>balance=0  不开启读写分离机制，所有读操作都发送到当前可用的writehost；</li><li>balance=1  全部的readHost与stand by writeHost参与select语句的负载均衡，简单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且M1与 M2互为主备)，正常情况下，M2,S1,S2都参与select语句的负载均衡。</li><li>balance=2  所有读操作都随机的在readhost和writehost上分发；</li><li>balance=3 所有读请求随机的分发到wiriterHost对应的readhost执行，writerHost不负担读压力。</li></ol><ul><li><p><strong>writeType 写入策略设置</strong></p><ul><li>writeType=0， 所有写操作发送到配置的第一个writeHost；</li><li>writeType=1，所有写操作都随机的发送到配置的writeHost；</li><li>writeType=2，不执行写操作</li></ul></li><li><p><strong>switchType 策略设置</strong></p><ul><li>switchType=-1，表示不自动切换；</li><li>switchType=1，默认值，自动切换；</li><li>switchType=2，基于MySQL 主从同步的状态决定是否切换；</li><li>switchType=3，基于MySQL galary cluster的切换机制（适合集群）（1.4.1），心跳语句为 show status like ‘wsrep%’。</li></ul></li></ul><p><heartbeat>select user()</heartbeat><br>检测后端MYSQL实例，SQL语句；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.149.129:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.149.130:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定读写请求，同时转发至后端MYSQL真实服务器，配置连接后端MYSQL用户名和密码（该用户名和密码为MYSQL数据库用户名和密码）；</p><p> 数据主机标签；</p><p> mycat结束标签；</p><h2 id="MyCAT读写分离测试"><a href="#MyCAT读写分离测试" class="headerlink" title="MyCAT读写分离测试"></a>MyCAT读写分离测试</h2><p>MyCAT配置完毕，直接启动即可；/usr/local/mycat/bin/mycat start即可，<br>查看8066和9066端口是否启动，其中8066用于WEB连接Mycat，9066用于SA|DBA管理端口；</p><p>netstat -ntl|grep -E –color “8066|9066”</p><p>进入MyCAT命令行界面：</p><p>mysql -h192.168.149.128 -ujfedu1 -pjfedu1 -P8066</p><p>插入数据，以9066端口登录。</p><h4 id="MyCAT管理命令"><a href="#MyCAT管理命令" class="headerlink" title="MyCAT管理命令"></a>MyCAT管理命令</h4><hr><p>MyCAT 自身有类似其他数据库的管理监控方式，可以通过 Mysql 命令行,登录管理端口(9066)执行相应 的 SQL 进行管理,也可以通过 jdbc 的方式进行远程连接管理,本小节主要讲解命令行的管理操作。</p><p>其中8066 数据端口，9066 管理端口，命令行的登陆是通过9066 管理端口来操作，登录方式类似于 mysql 的服务端登陆。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.168.149.128 -ujfedu1 –pjfedu1 -P8066</span><br><span class="line">mysql -h192.168.149.128 -ujfedu1 –pjfedu1 -P9066</span><br></pre></td></tr></table></figure><ul><li>-h 后面是主机，即当前 mycat 按照的主机地址；</li><li>-u Mycat server.xml 中配置的逻辑库用户；</li><li>-p Mycat server.xml 中配置的逻辑库密码；</li><li>-P 后面是端口 默认 9066,注意 P 是大写；</li></ul><p>数据端口与管理端口的配置端口修改，数据端口默认 8066,管理端口默认 9066 ,如果需要修改需要配置 server.xml，加入如下代码，例如将数据库端口改成3306:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serverPort"</span>&gt;</span>3306<span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"managerPort"</span>&gt;</span>9066<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>9066 管理端口登陆后，执行show @@help可以查看到所有命令：</p><p>常见管理命令如下：<br>查看当前的库<br>show @@database;</p><p>+———-+</p><p>| DATABASE |</p><p>+———-+</p><p>| testdb |</p><p>+———-+</p><p>1 row in set (0.00 sec)</p><ol><li>查看MyCAT数据节点的列表,dataNode节点：</li></ol><p>mysql&gt; show @@datanode;</p><p>其中,“NAME”表示 dataNode 的名称;“dataHost”表示对应 dataHost 属性的值,即数据主机; “ACTIVE”表示活跃连接数;“IDLE”表示闲置连接数;“SIZE”对应总连接数量。</p><p>有1个空闲连接，那我们去主从节点用 netstat -ntp 命令看看建立的连接情况：</p><ol><li>查看心跳报告：</li></ol><p>mysql&gt; show @@heartbeat;</p><p>该命令用于报告心跳状态</p><ol><li>查看Mycat的前端连接状态，即应用与mycat的连接：<br>mysql&gt; show @@connection\G<br>从上面获取到的连接 ID 属性，可以手动杀掉某个连接。<br>kill @@connection id,id,id</li><li>显示后端连接状态：<br>mysql&gt; show @@backend\G</li><li>显示数据源：<br>mysql&gt; show @@datasource;</li></ol><p>可以看到主从信息，同时可以看到读、写的次数；</p><h4 id="MyCAT状态监控"><a href="#MyCAT状态监控" class="headerlink" title="MyCAT状态监控"></a>MyCAT状态监控</h4><hr><p>MyCAT-WEB是基于mycat的一个性能监控工具，可以更有效的使用mycat管理mycat监控Mycat，让Mycat工作更加高效。Mycat-web的运行依赖 zookpeer ，需要提前安装Zookeeper服务，Zookeeper作为配置中心；</p><p>MyCAT监控 支持如下特点：</p><ul><li>支持对Mycat、Mysql性能监控 ；</li><li>支持对Mycat的JVM内存提供监控服务 ；</li><li>支持对线程的监控 ；</li><li>支持对操作系统的CPU、内存、磁盘、网络的监控 ；</li></ul><p>Zookeeper安装配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://apache.opencas.org/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz</span><br><span class="line">tar -zxvf zookeeper-3.4.6.tar.gz -C /usr/local/</span><br><span class="line">cd /usr/local/zookeeper-3.4.6/</span><br><span class="line">cd conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">cd /usr/local/zookeeper-3.4.6/bin/</span><br><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure><p>安装配置MyCAT-WEB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.mycat.io/mycat-web-1.0/Mycat-web-1.0-SNAPSHOT-20170102153329-linux.tar.gz</span><br><span class="line">tar -xvf Mycat-web-1.0-SNAPSHOT-20170102153329-linux.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure><p>#修改zookeeper注册中心地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mycat-web/mycat-web/WEB-INF/classes</span><br><span class="line">vim mycat.properties</span><br><span class="line">zookeeper=127.0.0.1:2181</span><br></pre></td></tr></table></figure><p>#启动MyCAT-WEB服务即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mycat-web/</span><br><span class="line">./start.sh &amp;</span><br></pre></td></tr></table></figure><p>#通过浏览器访问如图所示:</p><p>访问地址是：<a href="http://192.168.149.128:8082/mycat/" target="_blank" rel="noopener">http://192.168.149.128:8082/mycat/</a></p><p>连接MyCAT服务器，填写如下配置即可：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着互联网时代的发展，传统的数据库技术日趋成熟、计算机网络技术的飞速发展和应用范围的扩充，数据库应用已经普遍建立于计算机网络之上。此时集中式数据库系统表现出它的不足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集中式处理，势必造成性能瓶颈；&lt;/li&gt;
&lt;li&gt;应用程序集中在一台计算机上运行
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.dookt.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.dookt.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>RAID简介</title>
    <link href="http://www.dookt.com/post/59899.html"/>
    <id>http://www.dookt.com/post/59899.html</id>
    <published>2019-07-26T13:24:45.000Z</published>
    <updated>2019-07-31T05:20:52.670Z</updated>
    
    <content type="html"><![CDATA[<p>磁盘阵列（Redundant Arrays of Independent Drives，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。 </p><p>磁盘阵列是由很多块独立的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。</p><p>1.RAID 0：称为Stripping条带存储技术（条带），所有磁盘完全地并行读，并行写，是组建磁盘阵列最简单的一种形式，只需要2块以上的硬盘即可，成本低，可以提供整个磁盘的性能和吞吐量，但RAID 0没有提供数据冗余和错误修复功能，因此单块硬盘的损坏会导致所有的数据丢失。（提高读写性能，无备份，成本最低）<br>2.RAID 1：镜像存储，通过把两块磁盘中的一块磁盘的数据镜像到另一块磁盘上， 实现数据冗余，在两块磁盘上产生互为备份的数据，其容量仅等于一块磁盘的容量。当数据在写入一块磁盘时，会在另一块闲置的磁盘上生产镜像，在不影响性能情况下最大限度的保证系统的可靠性和可修复性；当原始数据繁忙时，可直接从镜像拷贝中读取数据（从两块硬盘中较快的一块中读出），提高读取性能。相反的，RAID 1的写入速度较缓慢。RAID 1一般支持“热交换”，即阵列中硬盘的移除或替换可以在系统运行状态下进行，无须中断退出系统。RAID 1是磁盘阵列中硬盘单位成本最高的，但它提供了很高的数据安全性、可靠性和可用性，当一块硬盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。（提高读速度，降低写速度，有备份，成本最高）<br>3.RAID 0+1：也被称为RAID 10，实际是将RAID 0和RAID 1结合的形式，在连续地以位或字节为单位分割数据并且并行读/写多个磁盘的同时，为每一块磁盘做镜像进行冗余。通过RAID 0+1的组合形式，数据除分布在多个盘上外，每个盘都有其物理镜像盘，提供冗余能力，允许一个以下磁盘故障，而不影响数据可用性，并且有快速读/写能力。RAID 0+1至少需要4个硬盘在磁盘镜像中建立带区集。RAID 0+1技术在保证数据高可靠性的同时，也保证了数据读/写的高效性。<br>4.RAID 5：是一种存储性能、数据安全和存储成本兼顾的存储解决方案。RAID 5可以理解为是RAID 0和RAID 1的折衷方案，RAID 5至少需要三块硬盘。RAID 5可以为系统提供数据安全保障，但保障程度要比镜像低而磁盘空间利用率要比镜像高。RAID 5具有和RAID 0相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较低，是目前运用较多的一种解决方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;磁盘阵列（Redundant Arrays of Independent Drives，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。 &lt;/p&gt;
&lt;p&gt;磁盘阵列是由很多块独立的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dookt.com/categories/Linux/"/>
    
    
      <category term="磁盘管理" scheme="http://www.dookt.com/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能优化企业实战</title>
    <link href="http://www.dookt.com/post/44413.html"/>
    <id>http://www.dookt.com/post/44413.html</id>
    <published>2019-07-26T12:51:48.000Z</published>
    <updated>2019-07-27T11:08:30.039Z</updated>
    
    <content type="html"><![CDATA[<p>随着企业网站访问量越来越大，服务器的压力也逐渐增加，主要体现在CPU使用率、内存、硬盘、网卡流量等方面资源占用情况很高。此时需对服务器性能进行调优，尽量在保持服务器的现有数量，然后对其各个环节参数进行优化。</p><p>本章向读者介绍Linux企业级性能服务器优化、TCP/IP报文、TCP三次握手及四次断开、Linux内核深入优化、Linux内核故障解决方案及对Linux性能进行评估等。</p><h4 id="TCP-IP报文详解"><a href="#TCP-IP报文详解" class="headerlink" title="TCP/IP报文详解"></a>TCP/IP报文详解</h4><p>TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p><p>TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地，而IP是给因特网的每台联网设备规定一个地址。TCP/IP 协议数据封装的过程包括：用户数据经过应用层协议封装后传递给传输层，传输层封装TCP头部，交给网络层，网络层封装IP头部后，再交给数据链路层，数据链路层封装Ethernet帧头和帧尾，交给物理层，物理层以比特流的形式将数据发送到物理线路上。</p><p>一般而言，不同的协议层对数据包有不同的称谓，数据包在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理，如图15-1所示：</p><p>优化Linux服务器，需要了解TCP协议相关信息，例如TCP/IP数据报文的内容及如何传输的。</p><p>IP数据包详解如下：</p><p>Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；<br>Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；<br>Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；<br>Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；<br>TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：<br>URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；<br>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；<br>PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；<br>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；<br>SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；<br>FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。<br>Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制；<br>TCP三次握手及四次断开<br>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换TCP窗口大小信息。</p><h4 id="TCP三次握手原理："><a href="#TCP三次握手原理：" class="headerlink" title="TCP三次握手原理："></a>TCP三次握手原理：</h4><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后客户端进入SYN_SENT状态，等待服务器的确认；<br>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>如图15-4所示为基于tcpdump抓取TCP/IP三次握手及数据包传输过程：</p><p>TCP四次挥手原理：<br>第一次挥手：主机A（可以使客户端，可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机B发送一个FIN报文段；此时，主机A进入FIN_WAIT_1状态；这表示主机A没有数据要发送给主机B；<br>第二次挥手：主机B收到了主机A发送的FIN报文段，向主机A回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机A进入FIN_WAIT_2状态；主机B告诉主机A，我“同意”你的关闭请求；<br>第三次挥手：主机B向主机A发送FIN报文段，请求关闭连接，同时主机B进入LAST_ACK状态；<br>第四次挥手：主机A收到主机B发送的FIN报文段，向主机B发送ACK报文段，然后主机A进入TIME_WAIT状态；主机B收到主机A的ACK报文段以后，就关闭连接；此时，主机A等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机A也可以关闭连接。<br>如图15-5所示为基于tcpdump抓取TCP/IP四次挥手及数据包传输过程：</p><h4 id="优化Linux文件打开最大数"><a href="#优化Linux文件打开最大数" class="headerlink" title="优化Linux文件打开最大数"></a>优化Linux文件打开最大数</h4><p>为了防止失控的进程破坏系统的性能，Unix和Linux会跟踪进程使用的大部分资源，并允许用户和系统管理员使用对进程的资源限制，例如控制某个进程打开的系统文件数、对某个用户打开系统进程数进行限制等，一般限制手段包括：软限制和硬限制。<br>软限制（soft limit）是内核实际执行的限制，任何进程都可以将软限制设置为任意小于等于对进程限制的硬限制的值，(noproc)最大线程数和(nofile)文件数；<br>硬限制（hard limit）是可以在任何时候任何进程中设置，但硬限制只能由超级用户修改。<br>Linux系统一切皆文件，对Linux进行各种操作，其实是对文件进行操作，文件可分为：普通文件、目录文件、链接文件和设备文件。而文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其值一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。<br>Linux系统默认已经打开的文件描述符包括：STDIN_FILENO 0表示标准输入、STDOUT_FILENO 1表示标准输出、STDERR_FILENO 2表示标准错误输出，默认打开一个新文件，它的文件描述符为3。<br>每个文件描述符与一个打开文件相对应，不同的文件描述符可以指向同一个文件。相同的文件可以被不同的进程打开，也可以在同一个进程中被多次打开。<br>Linux系统为每个进程维护了一个文件描述符表，该表的值都从0开始的，在不同的进程中你会看到相同的文件描述符，相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。Linux内核对文件操作，维护了3个数据结构概念如下：<br>进程级的文件描述符表；<br>系统级的打开文件描述符表；<br>文件系统的i-node表；<br>其中进程级的描述符表的每一个条目记录了单个文件描述符的相关信息，例如控制文件描述符操作的一组标志及对打开文件句柄的引用。Linux内核对所有打开的文件都维护了一个系统级的描述符表（open file description table）。将描述符表中的记录行称为打开文件句柄（open file handle），一个打开文件句柄存储了与一个打开文件相关的全部信息，详细信息如下：<br>当前文件偏移量；<br>打开文件时所使用的状态标识；<br>文件访问模式；<br>与信号驱动相关的设置；<br>对该文件i-node对象的引用；<br>文件类型和访问权限；<br>指针，指向该文件所持有的锁列表；<br>文件的各种属性。<br>默认Linux内核对每个用户设置了打开文件最大数为1024，对于高并发网站，是远远不够的，需要将默认值调整到更大，调整方法有两种：<br>Linux每个用户打开文件最大数临时设置方法，重启服务器该参数无效，命令行终端执行如下命令：<br>ulimit   -n  65535<br>Linux每个用户打开文件最大数永久设置方法，将如下代码加入内核限制文件/etc/security/limits.conf的末尾：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*    soft        noproc                  65535</span><br><span class="line">*    hard       noproc                  65535</span><br><span class="line">*    soft        nofile                    65535</span><br><span class="line">*    hard       nofile                    65535</span><br></pre></td></tr></table></figure><p>如上设置为对每个用户分别设置nofile、noproc最大数，如果需要对Linux整个系统设置文件最大数限制，需要修改/proc/sys/fs/file-max中的值，该值为Linux总文件打开数，例如设置为：echo 3865161233 &gt;/proc/sys/fs/file-max。</p><p>内核参数的优化<br>Linux /proc/sys目录下存放着多数内核的参数，并且可以在系统运行时进行更改，一般重新启动机器就会失效。而/etc/sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。</p><p>/proc/sys下内核文件与配置文件sysctl.conf中变量存在着对应关系，即修改sysct.conf配置文件，其实是修改/proc/sys相关参数，所以对Linux内核优化只需修改/etc/sysctl.conf文件即可。如下为BAT企业生产环境/etc/sysct.conf内核完整参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 10000</span><br><span class="line">net.ipv4.tcp_sack = 1</span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 4194304</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 4194304</span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line">net.core.somaxconn = 262144</span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_mem = 94500000 915000000 927000000</span><br><span class="line">net.ipv4.tcp_fin_timeout = 1</span><br><span class="line">net.ipv4.tcp_keepalive_time = 30</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65535</span><br></pre></td></tr></table></figure><h4 id="Linux内核常见参数详解："><a href="#Linux内核常见参数详解：" class="headerlink" title="Linux内核常见参数详解："></a>Linux内核常见参数详解：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps = 1</span><br><span class="line">该参数控制RFC 1323 时间戳与窗口缩放选项；</span><br><span class="line">net.ipv4.tcp_sack = 1</span><br><span class="line">选择性应答(SACK)是 TCP 的一项可选特性,可以提高某些网络中所有可用带宽的使用效率；</span><br><span class="line">net.ipv4.tcp_fack = 1</span><br><span class="line">打开FACK(Forward ACK) 拥塞避免和快速重传功能；</span><br><span class="line">net.ipv4.tcp_retrans_collapse = 1</span><br><span class="line">打开重传重组包功能，为0的时候关闭重传重组包功能；</span><br><span class="line">net.ipv4.tcp_syn_retries = 5</span><br><span class="line">对于一个新建连接，内核要发送多少个SYN 连接请求才决定放弃；</span><br><span class="line">net.ipv4.tcp_synack_retries = 5</span><br><span class="line">tcp_synack_retries显示或设定Linux在回应SYN要求时尝试多少次重新发送初始SYN,ACK封包后才决定放弃；</span><br><span class="line">net.ipv4.tcp_max_orphans = 131072</span><br><span class="line">系统所能处理不属于任何进程的TCP sockets最大数量；</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息；</span><br><span class="line">默认为180000，设为较小数值此项参数可以控制TIME_WAIT套接字的最大数量，避免服务器被大量的TIME_WAIT套接字拖死；</span><br><span class="line">net.ipv4.tcp_keepalive_time = 30</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 3</span><br><span class="line">如果某个TCP连接在空闲30秒后,内核才发起probe(探查)；</span><br><span class="line">如果probe 3次(每次3秒既tcp_keepalive_intvl值)不成功,内核才彻底放弃,认为该连接已失效；</span><br><span class="line">net.ipv4.tcp_retries1 = 3</span><br><span class="line">放弃回应一个TCP 连接请求前﹐需要进行多少次重试；</span><br><span class="line">net.ipv4.tcp_retries2 = 15</span><br><span class="line">在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试；</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">表示如果套接字由本端要求关闭，这个参数决定了它保持在 FIN-WAIT-2状态的时间；</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192</span><br><span class="line">表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数；</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">TCP建立连接的 3 次握手过程中，当服务端收到最初的 SYN 请求时，会检查应用程序的syn_backlog队列是否已满，启用syncookie，可以解决超高并发时的Can’t  Connect` 问题。但是会导致 TIME_WAIT 状态fallback为保持2MSL时间，高峰期时会导致客户端无可复用连接而无法连接服务器；</span><br><span class="line">net.ipv4.tcp_orphan_retries = 0</span><br><span class="line">关闭TCP连接之前重试多少次；</span><br><span class="line">net.ipv4.tcp_mem = 178368  237824     356736</span><br><span class="line">net.ipv4.tcp_mem[0]: 低于此值,TCP没有内存压力；</span><br><span class="line">net.ipv4.tcp_mem[1]: 在此值下,进入内存压力阶段；</span><br><span class="line">net.ipv4.tcp_mem[2]: 高于此值,TCP拒绝分配socket；</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">表示开启重用，允许将TIME-WAIT sockets重新用于新的TCP连接；</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br><span class="line">表示用于向外连接的端口范围；</span><br><span class="line">net.ipv4.ip_conntrack_max = 655360</span><br><span class="line">在内核内存中netfilter可以同时处理的“任务”（连接跟踪条目）；</span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br><span class="line">开启恶意icmp错误消息保护；</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">开启SYN洪水攻击保护。</span><br></pre></td></tr></table></figure><h4 id="Linux内核报错剖析"><a href="#Linux内核报错剖析" class="headerlink" title="Linux内核报错剖析"></a>Linux内核报错剖析</h4><p>企业生产环境Linux服务器正常运行，由于某种原因会导致内核报错或者抛出很多信息，根据系统SA可以快速定位Linux服务器故障，Linux内核日志一般存在messages日志中，可以通过命令tail -fn 100 /var/log/messages查看Linux内核日志，如下为Linux内核常见报错日志及生产环境解决报错的方案：</p><h5 id="Linux内核抛出net-ipv4-tcp-max-tw-buckets错误："><a href="#Linux内核抛出net-ipv4-tcp-max-tw-buckets错误：" class="headerlink" title="Linux内核抛出net.ipv4.tcp_max_tw_buckets错误："></a>Linux内核抛出net.ipv4.tcp_max_tw_buckets错误：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sep 23 04:45:55 localhost kernel: TCP: time wait bucket table overflow</span><br><span class="line">Sep 23 04:45:55 localhost kernel: TCP: time wait bucket table overflow</span><br><span class="line">Sep 23 04:45:55 localhost kernel: TCP: time wait bucket table overflow</span><br><span class="line">Sep 23 04:45:55 localhost kernel: TCP: time wait bucket table overflow</span><br><span class="line">Sep 23 04:45:55 localhost kernel: TCP: time wait bucket table overflow</span><br><span class="line">Sep 23 04:45:55 localhost kernel: TCP: time wait bucket table overflow</span><br><span class="line">Sep 23 04:45:55 localhost kernel: TCP: time wait bucket table overflow</span><br><span class="line">Sep 23 04:45:55 localhost kernel: TCP: time wait bucket table overflow</span><br><span class="line">Sep 23 04:45:55 localhost kernel: TCP: time wait bucket table overflow</span><br></pre></td></tr></table></figure><p>根据TCP协议定义的3次握手及四次断开连接规定，发起socket主动关闭的一方Socket将进入TIME_WAIT状态，TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)。<br>如果该值设置过小导致，当系统Time wait数量超过默认设置的值，即会抛出如上的警告信息，需要增加net.ipv4.tcp_max_tw_buckets的值，警告信息消除。<br>当然也不能设置过大，对于一个处理大量短连接的服务器，如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的Socket，甚至比处于Established状态下的Socket多的多，严重影响服务器的处理能力，甚至耗尽可用的Socket而停止服务，TIME_WAIT是TCP协议用以保证被重新分配的Socket不会受到之前残留的延迟重发报文影响的机制，是TCP传输必要的逻辑保证。</p><h5 id="Linux内核抛出Too-many-open-files错误："><a href="#Linux内核抛出Too-many-open-files错误：" class="headerlink" title="Linux内核抛出Too many open files错误："></a>Linux内核抛出Too many open files错误：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Benchmarking localhost (be patient)</span><br><span class="line">socket: Too many open files (24)</span><br><span class="line">socket: Too many open files (24)</span><br><span class="line">socket: Too many open files (24)</span><br><span class="line">socket: Too many open files (24)</span><br><span class="line">socket: Too many open files (24)</span><br></pre></td></tr></table></figure><p>每个文件描述符与一个打开文件相对应，不同的文件描述符可以指向同一个文件。相同的文件可以被不同的进程打开，也可以在同一个进程中被多次打开。Linux内核对应每个用户打开的文件最大数一般为1024，需要将该值调高满足大并发网站的访问。<br>Linux每个用户打开文件最大数永久设置方法，将如下代码加入内核限制文件/etc/security/limits.conf的末尾，Exit退出终端，重新登录即生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/security/limits.conf</span></span><br><span class="line">*    soft        noproc                  65535</span><br><span class="line">*    hard       noproc                  65535</span><br><span class="line">*    soft        nofile                    65535</span><br><span class="line">*    hard       nofile                    65535</span><br></pre></td></tr></table></figure><h5 id="Linux内核抛出possible-SYN-flooding-on-port-80-Sending-cookies错误："><a href="#Linux内核抛出possible-SYN-flooding-on-port-80-Sending-cookies错误：" class="headerlink" title="Linux内核抛出possible SYN flooding on port 80. Sending cookies错误："></a>Linux内核抛出possible SYN flooding on port 80. Sending cookies错误：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">May 31 14:20:14 localhost kernel: possible SYN flooding on port 80. Sending cookies.</span><br><span class="line">May 31 14:21:28 localhost kernel: possible SYN flooding on port 80. Sending cookies.</span><br><span class="line">May 31 14:22:44 localhost kernel: possible SYN flooding on port 80. Sending cookies.</span><br><span class="line">May 31 14:25:33 localhost kernel: possible SYN flooding on port 80. Sending cookies.</span><br><span class="line">May 31 14:27:06 localhost kernel: possible SYN flooding on port 80. Sending cookies.</span><br><span class="line">May 31 14:28:44 localhost kernel: possible SYN flooding on port 80. Sending cookies.</span><br><span class="line">May 31 14:28:51 localhost kernel: possible SYN flooding on port 80. Sending cookies.</span><br><span class="line">May 31 14:31:01 localhost kernel: possible SYN flooding on port 80. Sending cookies.</span><br></pre></td></tr></table></figure><p>此问题是由于SYN 队列已满，而触发SYN cookies，一般是由于大量的访问，或者恶意访问导致，也称之为SYN Flooding洪水攻击，与DDOS攻击类似。<br>完整的TCP连接的三次握手，假设一个用户A向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）。<br>一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源，数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的CPU时间和内存，何况还要不断对这个列表中的IP进行SYN+ACK的重试。<br>实际上如果服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃，即使服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，服务器拒绝提供服务，服务器受到了DDOS攻击，这里攻击的手段为DDOS中SYN Flood攻击（SYN洪水攻击）。</p><h5 id="防护DDOS攻击"><a href="#防护DDOS攻击" class="headerlink" title="防护DDOS攻击"></a>防护DDOS攻击</h5><p>防护DDOS攻击有两种手段，一是基于硬件专业防火墙、二是基于Linux内核简单防护，如果攻击流量特别大，单纯配置内核参数是无法抵挡的，还得依靠专业级硬件防火墙，如下为Linux内核防护DDOS优化参数，加入如下代码即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 8000</span><br><span class="line">net.ipv4.tcp_synack_retries = 2</span><br><span class="line">net.ipv4.tcp_syn_retries = 2</span><br></pre></td></tr></table></figure><h5 id="Linux内核抛出ip-conntrack-table-full-dropping-packet-错误："><a href="#Linux内核抛出ip-conntrack-table-full-dropping-packet-错误：" class="headerlink" title="Linux内核抛出ip_conntrack: table full, dropping packet.错误："></a>Linux内核抛出ip_conntrack: table full, dropping packet.错误：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">May  6 11:15:07 localhost kernel: nf_conntrack:table full, dropping packet.</span><br><span class="line">May  6 11:19:13 localhost kernel: nf_conntrack:table full, dropping packet.</span><br><span class="line">May  6 11:20:34 localhost kernel: nf_conntrack:table full, dropping packet.</span><br><span class="line">May  6 11:23:12 localhost kernel: nf_conntrack:table full, dropping packet.</span><br><span class="line">May  6 11:24:07 localhost kernel: nf_conntrack:table full, dropping packet.</span><br><span class="line">May  6 11:24:13 localhost kernel: nf_conntrack:table full, dropping packet.</span><br><span class="line">May  6 11:25:11 localhost kernel: nf_conntrack:table full, dropping packet.</span><br><span class="line">May  6 11:26:25 localhost kernel: nf_conntrack:table full, dropping packet.</span><br></pre></td></tr></table></figure><p>由于该服务器开启了iptables防火墙，WEB服务器收到了大量的连接，iptables会把所有的连接都做链接跟踪处理，这样iptables就会有一个链接跟踪表，当这个表满的时候，就会出现上面的错误。ip_conntrack是linux NAT的一个跟踪连接条目的模块，ip_conntrack模块会使用一个哈希表记录 tcp 通讯协议的established connection记录。<br>       如果是CentOS6.x系统，需执行：modprobe nf_conntrack命令，然后在内核优化文件中加入如下代码，sysctl –p使其内核文件生效，即可解决该报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.nf_conntrack_max = 655360</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = 36000</span><br></pre></td></tr></table></figure><p>如果是CentOS5.x系统，需执行：modprobe ip_conntrack命令，然后在内核优化文件中加入如下代码，sysctl –p使其内核文件生效，即可解决该报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_conntrack_max = 655350</span><br><span class="line">net.ipv4.netfilter.ip_conntrack_tcp_timeout_established = 10800</span><br></pre></td></tr></table></figure><h4 id="影响务器性能因素"><a href="#影响务器性能因素" class="headerlink" title="影响务器性能因素"></a>影响务器性能因素</h4><p>影响企业生产环境Linux服务器性能的因素有很多，一般分为两大类，分别为操作系统层级和应用程序级别。如下为各级别影响性能的具体项及性能评估的标准：</p><ul><li>操作系统级别</li><li>内存；</li><li>CPU；</li><li>磁盘I/O；</li><li>网络I/O带宽。</li><li>应用程序及软件</li><li>Nginx；</li><li>MySQL；</li><li>Tomcat;</li><li>PHP；</li><li>应用程序代码。</li></ul><h4 id="影响性能因素"><a href="#影响性能因素" class="headerlink" title="影响性能因素"></a>影响性能因素</h4><p>评判标准</p><ul><li>好</li><li>坏</li><li>糟糕</li></ul><ul><li>CPU<ul><li>user% + sys%&lt; 70%</li><li>user% + sys%= 85%</li><li>user% + sys% &gt;=90%</li></ul></li><li>内存<ul><li>Swap In（si）＝0</li><li>Swap Out（so）＝0</li><li>Per CPU with 10 page/s</li><li>More Swap In &amp; Swap Out</li></ul></li><li>磁盘<ul><li>iowait % &lt; 20%</li><li>iowait % =35%</li><li>iowait % &gt;= 50%</li></ul></li></ul><h4 id="Linux系统性能分析工具"><a href="#Linux系统性能分析工具" class="headerlink" title="Linux系统性能分析工具"></a>Linux系统性能分析工具</h4><p>常用系统性能分析命令: vmstat、sar、iostat、netstat、free、ps、top、iftop等；</p><p>常用系统性能组合分析命令；</p><ul><li>top、uptime                                  检查系统整体的负载、承受能力；</li><li>vmstat、sar、iostat 、top                    检测是否是CPU瓶颈；</li><li>free、vmstat                                 检测是否是内存瓶颈；</li><li>iostat                                       检测是否是磁盘I/O瓶颈；</li><li>netstat、iftop                               检测是否是网络带宽瓶颈。</li></ul><h4 id="Linux服务器性能评估与优化"><a href="#Linux服务器性能评估与优化" class="headerlink" title="Linux服务器性能评估与优化"></a>Linux服务器性能评估与优化</h4><p>Linux服务器性能评估与优化是一项长期的工作，需要随时关注网站服务器的运行状态，及时作出相应的调整，如下为Linux服务器性能评估及优化方案：</p><h5 id="Linux系统整体性能评估"><a href="#Linux系统整体性能评估" class="headerlink" title="Linux系统整体性能评估"></a>Linux系统整体性能评估</h5><p>uptime命令主要用于查看当前服务器整体性能，例如CPU、负载、内存等值的总览，如下为uptime命令应用案例及详解：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 ~]# uptime</span><br><span class="line">13:38:00 up 112 days,  14:01,  5 users,  load average: 6.22, 1.02, 0.91</span><br></pre></td></tr></table></figure><p>Load average负载有三个值，分别表示：最近1分钟、5分钟、15分钟系统的负载，三个值的大小一般不能大于系统逻辑CPU核数的2倍，例如Linux操作系统有4个逻辑CPU，如果load average的三个值长期大于8时，说明CPU很繁忙，负载很高，可能会影响系统性能，但是偶尔大于8时，可以不用担心，一般不会影响系统性能。<br>如果load average的输出值小于CPU逻辑个数的2倍，则表示CPU还有空闲的时间片，例如案例中CPU负载为6.22，表示CPU或者服务器是比较空闲的。基于此参数不能完全确认服务器的性能瓶颈，需要借助其他工具进一步判断。</p><h5 id="CPU性能评估"><a href="#CPU性能评估" class="headerlink" title="CPU性能评估"></a>CPU性能评估</h5><p>利用vmstat命令监控系统CPU，该命令可以显示关于系统各种资源之间相关性能的简要信息，主要用它来查看CPU负载及队列情况。</p><h6 id="Vmstat输出结果详解"><a href="#Vmstat输出结果详解" class="headerlink" title="Vmstat输出结果详解"></a>Vmstat输出结果详解</h6><ul><li>r             列表示运行和等待cpu时间片的进程数，这个值如果长期大于系统CPU的个数，说明CPU不足，需要增加CPU；</li><li>b             列表示在等待资源的进程数，比如正在等待I/O、或者内存交换等；</li><li>us            列显示了用户进程消耗的CPU 时间百分比。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于50%，就需要考虑优化程序或算法；</li><li>sy            列显示了内核进程消耗的CPU时间百分比。Sy的值较高时，说明内核消耗的CPU资源很多；<br>us+sy的参考值为80%，如果us+sy大于80%说明可能存在CPU资源不足。<br>利用sar命令监控系统CPU，sar功能很强大，可以对系统的每个方面进行单独的统计，但是使用sar命令会增加系统开销，不过这些开销是可以评估的，对系统的统计结果不会有很大影响。如图15-7所示，为sar命令对某个系统的CPU统计输出：</li></ul><h6 id="Sar输出结果详解如下："><a href="#Sar输出结果详解如下：" class="headerlink" title="Sar输出结果详解如下："></a>Sar输出结果详解如下：</h6><ul><li>%user                                 列显示了用户进程消耗的CPU 时间百分比；</li><li>%nice                                 列显示了运行正常进程所消耗的CPU 时间百分比；</li><li>%system                             列显示了系统进程消耗的CPU时间百分比；</li><li>%iowait                              列显示了IO等待所占用的CPU时间百分比；</li><li>%idle                                  列显示了CPU处在空闲状态的时间百分比；</li><li>%steal                                列显示了在内存相对紧张的环境下page in强制对不同的页面进行的steal操作。</li></ul><h5 id="内存性能评估"><a href="#内存性能评估" class="headerlink" title="内存性能评估"></a>内存性能评估</h5><p>利用free指令监控内存，free是监控linux内存使用状况最常用的指令。</p><p>一般而言，服务器内存可以通过如下方法判断是否空余：</p><ul><li>应用程序可用内存/系统物理内存&gt;70%时，表示系统内存资源非常充足，不影响系统性能。</li><li>应用程序可用内存/系统物理内存&lt;20%时，表示系统内存资源紧缺，需要增加系统内存，20%&lt;应用程序可用内存/系统物理内存&lt;70%时，表示系统内存资源基本能满足应用需求，暂时不影响系统性能。</li></ul><h5 id="磁盘I-O性能评估"><a href="#磁盘I-O性能评估" class="headerlink" title="磁盘I/O性能评估"></a>磁盘I/O性能评估</h5><p>利用iostat评估磁盘性能，监控磁盘IO读写及带宽。</p><h6 id="Iostat输出结果详解如下："><a href="#Iostat输出结果详解如下：" class="headerlink" title="Iostat输出结果详解如下："></a>Iostat输出结果详解如下：</h6><ul><li>Blk_read/s                表示每秒读取的数据块数；</li><li>Blk_wrtn/s                表示每秒写入的数据块数；</li><li>Blk_read                  表示读取的所有块数；</li><li>Blk_wrtn                  表示写入的所有块数。</li></ul><p>可以通过Blk_read/s和Blk_wrtn/s的值对磁盘的读写性能有一个基本的了解，如果Blk_wrtn/s值很大，表示磁盘的写操作很频繁，可以考虑优化磁盘或者优化程序，如果Blk_read/s值很大，表示磁盘直接读取操作很多，可以将读取的数据放入内存中进行操作。</p><p>利用sar评估磁盘性能，通过sar -d组合，可以对系统的磁盘IO做一个基本的统计。</p><h6 id="Sar输出结果详解如下：-1"><a href="#Sar输出结果详解如下：-1" class="headerlink" title="Sar输出结果详解如下："></a>Sar输出结果详解如下：</h6><ul><li>await表示平均每次设备I/O操作的等待时间（以毫秒为单位）；</li><li>svctm表示平均每次设备I/O操作的服务时间（以毫秒为单位）；</li><li>%util表示一秒中有百分之几的时间用于I/O操作；</li></ul><p>磁盘IO性能，评判标准：正常情况下svctm应该是小于await值的，而svctm的大小和磁盘性能有关，CPU、内存的负荷也会对svctm值造成影响，过多的请求也会间接的导致svctm值的增加。<br>await值的大小一般取决与svctm的值和I/O队列长度以及I/O请求模式，如果svctm的值与await很接近，表示几乎没有I/O等待，磁盘性能很好，如果await的值远高于svctm的值，则表示I/O队列等待太长，系统上运行的应用程序将变慢，此时可以通过更换更快的硬盘来解决问题。<br>%util项的值也是衡量磁盘I/O的一个重要指标，如果%util接近100%，表示磁盘产生的I/O请求太多，I/O系统已经满负荷的在工作，该磁盘可能存在瓶颈。长期下去，势必影响系统的性能，可以通过优化程序或者通过更换更高、更快的磁盘来解决此问题。</p><h4 id="网络性能评估"><a href="#网络性能评估" class="headerlink" title="网络性能评估"></a>网络性能评估</h4><ul><li>通过ping命令检测网络的连通性</li><li>通过netstat –i组合检测网络接口状况</li><li>通过netstat –r组合检测系统的路由表信息</li><li>通过sar -n组合显示系统的网络运行状态</li><li>通过iftop -i eth0 查看网卡流量，详细参数如下，</li></ul><p>&lt;=                               客户端流入的流量；</p><p>=&gt;                               服务器端流出的流量；</p><p>TX                              发送流量；</p><p>RX                              接收流量；</p><p>TOTAL                       总流量；</p><p>Cumm                         运行iftop到目前时间的总流量；</p><p>peak                         流量峰值；</p><p>rates                         分别表示过去 2s 10s 40s 的平均流量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着企业网站访问量越来越大，服务器的压力也逐渐增加，主要体现在CPU使用率、内存、硬盘、网卡流量等方面资源占用情况很高。此时需对服务器性能进行调优，尽量在保持服务器的现有数量，然后对其各个环节参数进行优化。&lt;/p&gt;
&lt;p&gt;本章向读者介绍Linux企业级性能服务器优化、TCP
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dookt.com/categories/Linux/"/>
    
    
      <category term="运维基本功" scheme="http://www.dookt.com/tags/%E8%BF%90%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
  </entry>
  
  <entry>
    <title>pyenv安装</title>
    <link href="http://www.dookt.com/post/651295d4.html"/>
    <id>http://www.dookt.com/post/651295d4.html</id>
    <published>2019-07-26T10:07:51.000Z</published>
    <updated>2019-07-31T05:30:59.241Z</updated>
    
    <content type="html"><![CDATA[<p>Pyenv是多版本Python管理器,可以同时管理多个Python版本共存, 区别于virtualenv.</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/yyuu/pyenv.git ~/.pyenv</span><br><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line">export PYENV_ROOT="$HOME/.pyenv"</span><br><span class="line">export PATH="$PYENV_ROOT/bin:$PATH"</span><br><span class="line">eval "$(pyenv init -)"</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>基本过程是官网下载源码包然后安装, 需要安装gcc, 等库的依赖安装.</p><h5 id="查看支持的版本"><a href="#查看支持的版本" class="headerlink" title="查看支持的版本"></a>查看支持的版本</h5><p>pyenv install –list</p><h5 id="centos上装python3需要先安装一些依赖包"><a href="#centos上装python3需要先安装一些依赖包" class="headerlink" title="centos上装python3需要先安装一些依赖包"></a>centos上装python3需要先安装一些依赖包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum groupinstall <span class="string">"Development tools"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install zlib-devel bzip2-devel openssl-devel ncurses-devel \</span></span><br><span class="line">sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br></pre></td></tr></table></figure><h5 id="开始安装python3-6-4"><a href="#开始安装python3-6-4" class="headerlink" title="开始安装python3.6.4"></a>开始安装python3.6.4</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install -v 3.6.4&lt;/pre&gt;</span><br></pre></td></tr></table></figure><h5 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pyenv global 3.6.4</span><br><span class="line">pyenv versions</span><br><span class="line">  system</span><br><span class="line">* 3.6.4 (set by /root/.pyenv/version)</span><br></pre></td></tr></table></figure><h5 id="查看当前系统包含的版本。-表示当前正在使用的版本"><a href="#查看当前系统包含的版本。-表示当前正在使用的版本" class="headerlink" title="查看当前系统包含的版本。*表示当前正在使用的版本"></a>查看当前系统包含的版本。*表示当前正在使用的版本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br><span class="line">* system (set by /root/.pyenv/version)</span><br><span class="line">3.6.4</span><br></pre></td></tr></table></figure><h5 id="相关注意事项"><a href="#相关注意事项" class="headerlink" title="相关注意事项"></a>相关注意事项</h5><p>因各种原因, 下载速度可能只有几KB, 甚至超时, 可将下载地址替换成国内镜像后在下载.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd  ~/.pyenv/plugins/python-build/share/python-build/</span><br><span class="line">vim 3.5.2 (如果你下载别的版本, 你就改别的文件)</span><br><span class="line">将里面下载地址改成sohu的镜像地址：</span><br><span class="line">https://www.python.org/ftp/python/3.5.2/Python-3.5.2.tar.xz</span><br><span class="line">http://mirrors.sohu.com/python/3.5.2/Python-3.5.2.tar.xz</span><br></pre></td></tr></table></figure><p>附搜狐镜像地址：<a href="http://mirrors.sohu.com/python/" target="_blank" rel="noopener">http://mirrors.sohu.com/python/</a><br>pip安装各种库也经常容易timeout.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat ~/.pip/pip.conf</span><br><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">trusted-host = pypi.douban.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pyenv是多版本Python管理器,可以同时管理多个Python版本共存, 区别于virtualenv.&lt;/p&gt;
&lt;h5 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h5&gt;&lt;figure clas
      
    
    </summary>
    
      <category term="Python" scheme="http://www.dookt.com/categories/Python/"/>
    
    
      <category term="Python基础" scheme="http://www.dookt.com/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux硬盘故障修复</title>
    <link href="http://www.dookt.com/post/57688.html"/>
    <id>http://www.dookt.com/post/57688.html</id>
    <published>2019-07-26T10:04:50.000Z</published>
    <updated>2019-07-31T05:30:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>企业服务器运维中，经常会发现操作系统的分区变成只读文件系统，错误提示信息为“Read-only filesystem”，出现只读文件系统，会导致只能读取，而无法写入新文件、新数据等操作。</p><p>造成该问题的原因包括：磁盘老旧长期大量的读写、文件系统文件被破坏、磁盘碎片文件、异常断电、读写中断等等。</p><p>以CentOS 7 Linux为案例，来修复文件系统，步骤如下：</p><h5 id="远程备份本地重要数据。"><a href="#远程备份本地重要数据。" class="headerlink" title="远程备份本地重要数据。"></a>远程备份本地重要数据。</h5><p>出现只读文件系统，需先备份其他重要数据，基于rsync|scp远程备份，/data为源目录，/backup/2018/为目标备份目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /data/ root@192.168.21.98:/backup/2017/</span><br><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure><h5 id="如果重新挂载-系统无法解决问题，则需重启服务器"><a href="#如果重新挂载-系统无法解决问题，则需重启服务器" class="headerlink" title="如果重新挂载/系统无法解决问题，则需重启服务器"></a>如果重新挂载/系统无法解决问题，则需重启服务器</h5><p>以CD/DVD光盘引导进入Linux Rescue修复模式，如图所示，光标选择“Troubleshooting”,按Enter键，然后选择“Rescue a CentOS system”，按Enter键。</p><p>光盘引导进入修复模式，</p><ul><li><p>选择Continue继续进入系统</p></li><li><p>登录修复模式，执行如下命令，df –h显示原来的文件系统</p></li><li><p>更改root目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chroot /mnt/sysimage</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure></li><li><p>切换原分区目录<br>对有异常的分区进行检测并修复，根据文件系统类型，执行相应的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sda3</span><br><span class="line">fsck.ext4 /dev/sda3 –y</span><br></pre></td></tr></table></figure></li></ul><h5 id="修复完成之后，重启系统即可"><a href="#修复完成之后，重启系统即可" class="headerlink" title="修复完成之后，重启系统即可"></a>修复完成之后，重启系统即可</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;企业服务器运维中，经常会发现操作系统的分区变成只读文件系统，错误提示信息为“Read-only filesystem”，出现只读文件系统，会导致只能读取，而无法写入新文件、新数据等操作。&lt;/p&gt;
&lt;p&gt;造成该问题的原因包括：磁盘老旧长期大量的读写、文件系统文件被破坏、磁盘碎
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dookt.com/categories/Linux/"/>
    
    
      <category term="系统管理" scheme="http://www.dookt.com/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL最常见的报错信息</title>
    <link href="http://www.dookt.com/post/29811.html"/>
    <id>http://www.dookt.com/post/29811.html</id>
    <published>2019-07-26T10:04:05.000Z</published>
    <updated>2019-07-31T05:29:58.966Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个运维人，MySQL启动不了了，该如何排查呢？</p><h5 id="MySQL重启报错"><a href="#MySQL重启报错" class="headerlink" title="MySQL重启报错"></a>MySQL重启报错</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redirecting to /bin/systemctl restart mariadb</span><br><span class="line">Job for mariadb.service failed because the control process exited with error code. See "systemctl status mariadb.service" and "journalctl -xe" for details.</span><br></pre></td></tr></table></figure><p>解决方法：</p><ul><li>journalctl –xe查看MYSQL错误信息</li><li>关闭服务器selinux安全策略，setenforce 0</li><li>检查MYSQL|Mariadb通过什么样的方式部署的</li><li>检查其配置文件/etc/my.cnf，datadir数据目录是否配置</li><li>确认数据库的数据目录mysql用户是否拥有读写权限</li><li>检查数据库目录是否初始化，是否包括mysql、test基础库</li><li>检查socket文件所在的路径，是否存在socket文件，权限是否正确</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个运维人，MySQL启动不了了，该如何排查呢？&lt;/p&gt;
&lt;h5 id=&quot;MySQL重启报错&quot;&gt;&lt;a href=&quot;#MySQL重启报错&quot; class=&quot;headerlink&quot; title=&quot;MySQL重启报错&quot;&gt;&lt;/a&gt;MySQL重启报错&lt;/h5&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.dookt.com/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://www.dookt.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用expect实现无交互操作远程主机</title>
    <link href="http://www.dookt.com/post/38203.html"/>
    <id>http://www.dookt.com/post/38203.html</id>
    <published>2019-07-26T10:03:00.000Z</published>
    <updated>2019-07-27T11:08:30.040Z</updated>
    
    <content type="html"><![CDATA[<p>对于一些需要交互输入的命令可以使用expect。比如ssh ftp scp telnet</p><p>expect是一款自动化的脚本解释型的工具。<br>expect基于tcl脚本，expect脚本的运行需要tcl的支持。<br>远程登录linux服务器的时候，ssh命令需要手工输入密码，当登录多台机器的时候就会非常繁琐。<br>expect就可以根据设定的规则，自动帮我们输入密码，大大节省了时间。</p><h4 id="查看远程主机的负载"><a href="#查看远程主机的负载" class="headerlink" title="查看远程主机的负载"></a>查看远程主机的负载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat mint1.exp                #扩展名为exp表示是expect脚本</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect             <span class="comment">#解释器(该命令不能直接再Linux上执行,需要使用expect脚本执行)</span></span></span><br><span class="line">spawn ssh root@172.17.0.2 uptime  #执行ssh命令,开头必须有spawn,否则无法交互  </span><br><span class="line">expect "*password*"           #利用expect获取ssh命令输出字符串是否为*password*,"*"为通配符</span><br><span class="line">send "123456\n"              #当获取到*password*时,发送密码123456给系统,\n为换行,可以用\r(回车)</span><br><span class="line">expect eof                    #结束expect</span><br></pre></td></tr></table></figure><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><p>[root@mint mint]# expect mint1.exp<br>spawn ssh <a href="mailto:root@172.17.0.2" target="_blank" rel="noopener">root@172.17.0.2</a> uptime<br><a href="mailto:root@172.17.0.2" target="_blank" rel="noopener">root@172.17.0.2</a>‘s password:<br> 09:12:44 up 40 min,  0 users,  load average: 0.45, 0.50, 0.46</p><h4 id="使用read命令-创造交互式输入"><a href="#使用read命令-创造交互式输入" class="headerlink" title="使用read命令,创造交互式输入"></a>使用read命令,创造交互式输入</h4><h5 id="read-shell脚本"><a href="#read-shell脚本" class="headerlink" title="read shell脚本"></a>read shell脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat read_shell.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -p "Please input your username:" name</span><br><span class="line">read -p "please input your password:" pass</span><br><span class="line">read -p "Please input your email:" mail</span><br><span class="line">echo -n "your username is $name,"</span><br><span class="line">echo -n "your password is $pass,"</span><br><span class="line">echo "your email is $mail."</span><br></pre></td></tr></table></figure><h5 id="read-expect脚本"><a href="#read-expect脚本" class="headerlink" title="read expect脚本"></a>read expect脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">spawn /bin/bash read_shell.sh              #执行上述shell脚本</span><br><span class="line">expect &#123;                               #expect&#123;&#125;相当于多个expect</span><br><span class="line">    "username" &#123;exp_send "mint\r";exp_continue&#125;        #获取到的信息是username,则自动输入mint</span><br><span class="line">    "*pass*" &#123;send "123456\r";exp_continue&#125;     #获取到的信息是*xinghao*sdfafsfdfsaafsda asfdf aa*</span><br><span class="line">    "*mail*" &#123;exp_send "1101893634@qq.com\r"&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="expect-eof-执行结果"><a href="#expect-eof-执行结果" class="headerlink" title="expect eof #执行结果"></a>expect eof #执行结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expect read_expect.exp&amp;nbsp;</span><br><span class="line">spawn /bin/bash read_shell.sh</span><br><span class="line">Please input your username:mint</span><br><span class="line">please input your password:123456</span><br><span class="line">Please input your email:1101893634@qq.com</span><br><span class="line">your username is mint,your password is 123456,your email is 1101893634@qq.com.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一些需要交互输入的命令可以使用expect。比如ssh ftp scp telnet&lt;/p&gt;
&lt;p&gt;expect是一款自动化的脚本解释型的工具。&lt;br&gt;expect基于tcl脚本，expect脚本的运行需要tcl的支持。&lt;br&gt;远程登录linux服务器的时候，ssh命令
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dookt.com/categories/Linux/"/>
    
    
      <category term="运维基本功" scheme="http://www.dookt.com/tags/%E8%BF%90%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
  </entry>
  
  <entry>
    <title>Centos7网卡名称重命名及root密码重置</title>
    <link href="http://www.dookt.com/post/36934.html"/>
    <id>http://www.dookt.com/post/36934.html</id>
    <published>2019-07-26T10:02:04.000Z</published>
    <updated>2019-07-31T05:22:18.050Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS7服务器，默认网卡名为ifcfg-eno16777736，如果我们想改成ifcfg-eth0，使用如下步骤即可：</p><h5 id="编辑-etc-sysconfig-grub文件"><a href="#编辑-etc-sysconfig-grub文件" class="headerlink" title="编辑/etc/sysconfig/grub文件"></a>编辑/etc/sysconfig/grub文件</h5><p>命令为vim /etc/sysconfig/grub，在倒数第二行quiet后加入如下代码，并如图3-14所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ifnames=0 biosdevname=0</span><br></pre></td></tr></table></figure><h5 id="生成新的grub-cfg文件"><a href="#生成新的grub-cfg文件" class="headerlink" title="生成新的grub.cfg文件"></a>生成新的grub.cfg文件</h5><p>执行命令grub2-mkconfig -o /boot/grub2/grub.cfg，生成新的grub.cfg文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><h5 id="重命名网卡名称"><a href="#重命名网卡名称" class="headerlink" title="重命名网卡名称"></a>重命名网卡名称</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv ifcfg-eno16777736 ifcfg-eth0  </span><br><span class="line">sed -i 's/ifcfg-eno16777736/eth0/g' ifcfg-eth0</span><br></pre></td></tr></table></figure><h5 id="重启服务器验证网卡名称是否已修改"><a href="#重启服务器验证网卡名称是否已修改" class="headerlink" title="重启服务器验证网卡名称是否已修改"></a>重启服务器验证网卡名称是否已修改</h5><h5 id="CentOS7服务器忘记密码："><a href="#CentOS7服务器忘记密码：" class="headerlink" title="CentOS7服务器忘记密码："></a>CentOS7服务器忘记密码：</h5><p>修改CentOS7 ROOT密码非常简单，只需登录系统，执行命令passwd回车即可，但是如果忘记ROOT，无法登录系统，该如何去重置ROOT用户的密码呢？如下为重置ROOT用户的密码的方法：</p><ul><li><p>Reboot重启系统，系统启动进入欢迎界面，加载内核步骤时，按e，然后选中”CentOS Linux （3.10.0-327.e17.x86_64）7 （Core)”</p></li><li><p>继续按e进入编辑模式，找到ro crashkernel=auto xxx项，将ro改成rw init=/sysroot/bin/sh，如图3-19所示：</p></li><li><p>按ctrl+x进入单用户模式</p></li><li><p>执行命令chroot /sysroot访问系统，并使用passwd修改root密码</p></li><li><p>更新系统信息，touch /.autorelabel，执行命令touch /.autorelabel，在/目录下创建一个.autorelabel文件，如果该文件存在，系统在重启时就会对整个文件系统进行relabeling重新标记，可以理解为对文件进行底层权限的控制和标记，如果seLinux属于disabled关闭状态则不需要执行这条命令</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CentOS7服务器，默认网卡名为ifcfg-eno16777736，如果我们想改成ifcfg-eth0，使用如下步骤即可：&lt;/p&gt;
&lt;h5 id=&quot;编辑-etc-sysconfig-grub文件&quot;&gt;&lt;a href=&quot;#编辑-etc-sysconfig-grub文件&quot; cl
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dookt.com/categories/Linux/"/>
    
    
      <category term="系统管理" scheme="http://www.dookt.com/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>解决Nginx报错The plain HTTP request was sent to HTTPS port</title>
    <link href="http://www.dookt.com/post/23576.html"/>
    <id>http://www.dookt.com/post/23576.html</id>
    <published>2019-07-26T10:01:26.000Z</published>
    <updated>2019-07-31T05:22:39.745Z</updated>
    
    <content type="html"><![CDATA[<p>从报错的字面意思上来看，是因为HTTP请求被发送到HTTPS端口，这种报错多出现在Nginx既处理HTTP请求又处理HTTPS请求的情况。</p><h5 id="修改nginx对应虚拟机的配置文件，找到https段"><a href="#修改nginx对应虚拟机的配置文件，找到https段" class="headerlink" title="修改nginx对应虚拟机的配置文件，找到https段"></a>修改nginx对应虚拟机的配置文件，找到https段</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443;</span><br><span class="line">    ssl on;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改为如下即可实现http和https共存："><a href="#修改为如下即可实现http和https共存：" class="headerlink" title="修改为如下即可实现http和https共存："></a>修改为如下即可实现http和https共存：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从报错的字面意思上来看，是因为HTTP请求被发送到HTTPS端口，这种报错多出现在Nginx既处理HTTP请求又处理HTTPS请求的情况。&lt;/p&gt;
&lt;h5 id=&quot;修改nginx对应虚拟机的配置文件，找到https段&quot;&gt;&lt;a href=&quot;#修改nginx对应虚拟机的配置文件
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dookt.com/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="http://www.dookt.com/tags/Nginx/"/>
    
  </entry>
  
</feed>
