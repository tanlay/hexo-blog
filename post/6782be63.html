<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客系统"><meta name="keywords" content="Nginx, Zabbix, Shell, Python, OPS, HA"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Docker入门 | MINT</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Docker入门</h1><a id="logo" href="/.">MINT</a><p class="description">感谢平庸与我随行!</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Docker入门</h1><div class="post-meta"><a href="/post/6782be63.html#comments" class="comment-count"></a><p><span class="date">Aug 13, 2019</span><span><a href="/categories/Docker/" class="category">Docker</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>Docker是Docker项目开发的一种容器格式。docker命令可以运行、停止、启动、检查容器。</p>
<h4 id="Docker-Hub-Registry"><a href="#Docker-Hub-Registry" class="headerlink" title="Docker Hub Registry"></a>Docker Hub Registry</h4><p>提供了个人与组织保存和开发Docker容器镜像的地方</p>
<h4 id="Docker镜像和容器"><a href="#Docker镜像和容器" class="headerlink" title="Docker镜像和容器"></a>Docker镜像和容器</h4><p>容器化的目的是将应用程序运行所需要的所有组件集合在一个单一而独立的单元中。对于Docker来说，这个单元被称为镜像。</p>
<p>镜像：是一个静态单元，它是容器运行的应用程序以及应用程序执行所需要的库、配置文件、可执行程序或者其他组件。</p>
<p>容器：指的是一个已运行的Docker镜像的实例。</p>
<h4 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h4><h5 id="查找Docker组件信息的命令"><a href="#查找Docker组件信息的命令" class="headerlink" title="查找Docker组件信息的命令"></a>查找Docker组件信息的命令</h5><ul>
<li>docker version：查看docker版本</li>
<li>docker info：查看docker系统信息</li>
<li>docker help：查看与docker命令一起使用的命令或选项</li>
<li>docker history：查看镜像历史</li>
<li>docker inspect：查看镜像或者容器信息</li>
<li>docker port：列出容器的端口映射</li>
</ul>
<h5 id="操作正在运行的容器的命令"><a href="#操作正在运行的容器的命令" class="headerlink" title="操作正在运行的容器的命令"></a>操作正在运行的容器的命令</h5><ul>
<li>docker ps：列出正在运行的容器</li>
<li>docker attach：将另一个命令附加到正在运行的容器上</li>
<li>docker exec：在正在运行的容器中执行命令</li>
<li>docker inspect：审查容器的元数据</li>
<li>docker cp：从容器中复制文件到宿主机</li>
<li>docker diff：检查容器从启动后其文件系统所做的改变</li>
</ul>
<h5 id="操作镜像的命令"><a href="#操作镜像的命令" class="headerlink" title="操作镜像的命令"></a>操作镜像的命令</h5><ul>
<li>docker images：查看系统上的镜像</li>
<li>docker run：运行镜像</li>
<li>docker pull：从registry上拉取镜像</li>
<li>docker push：将镜像传到registry中</li>
<li>docker save：将镜像保存为tarball</li>
<li>docker load：将tarball加载到本地镜像</li>
<li>docker export：从容器中将文件系统导出成本地文件系统的tarball文件</li>
</ul>
<h5 id="操作Docker-Registry的命令"><a href="#操作Docker-Registry的命令" class="headerlink" title="操作Docker Registry的命令"></a>操作Docker Registry的命令</h5><ul>
<li>docker search：在registry中搜索镜像</li>
<li>docker login：登陆到Docker Hub Registry（可以通过自己的账号推送拉取镜像）</li>
<li>docker logout：从Docker Hub Registry中登出</li>
</ul>
<h5 id="修改现存的镜像的命令"><a href="#修改现存的镜像的命令" class="headerlink" title="修改现存的镜像的命令"></a>修改现存的镜像的命令</h5><ul>
<li>docker tag：未镜像添加一个名字</li>
<li>docker rename：修改镜像名字</li>
</ul>
<h5 id="修改容器的状态的命令"><a href="#修改容器的状态的命令" class="headerlink" title="修改容器的状态的命令"></a>修改容器的状态的命令</h5><ul>
<li>docker stop：停止正在运行的容器</li>
<li>docker start：启动已经停止的容器</li>
<li>docker restart：重启启动容器</li>
<li>docker pause：暂停正在运行的容器</li>
<li>docker unpause：重新启动已经暂停的容器</li>
<li>docker kill：向容器发送kill信号或其他信号</li>
</ul>
<h5 id="查看Docker的活动的命令"><a href="#查看Docker的活动的命令" class="headerlink" title="查看Docker的活动的命令"></a>查看Docker的活动的命令</h5><ul>
<li>docker events：查看Docker服务器的事件</li>
<li>docker top：查看容器的进程</li>
<li>docker logs：查看容器产生的日志消息</li>
<li>docker stats：查看容器的CPU和内存使用统计</li>
<li>docker wait：查看容器直到它停止</li>
</ul>
<h5 id="创建镜像和容器的命令"><a href="#创建镜像和容器的命令" class="headerlink" title="创建镜像和容器的命令"></a>创建镜像和容器的命令</h5><ul>
<li>docker build：从头构建镜像</li>
<li>docker commit：从容器创建镜像</li>
<li>docker create：从镜像创建容器但是不运行它</li>
<li>docker import：将文件系统导入镜像中</li>
</ul>
<h3 id="部署搭建Docker运行环境"><a href="#部署搭建Docker运行环境" class="headerlink" title="部署搭建Docker运行环境"></a>部署搭建Docker运行环境</h3><h4 id="在Centos7系统中安装docker"><a href="#在Centos7系统中安装docker" class="headerlink" title="在Centos7系统中安装docker"></a>在Centos7系统中安装docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ sudo yum -y install epel-release</span><br><span class="line">[mint@ali-mint ~]$ sudo yum -y install docker</span><br><span class="line">[mint@ali-mint ~]$ systemctl restart docker</span><br><span class="line">[mint@ali-mint ~]$ systemctl enabled docker</span><br><span class="line">[mint@ali-mint ~]$ systemctl status docker</span><br><span class="line">[mint@ali-mint ~]$ docker version</span><br></pre></td></tr></table></figure>

<h4 id="在ubuntu系统安装docker"><a href="#在ubuntu系统安装docker" class="headerlink" title="在ubuntu系统安装docker"></a>在ubuntu系统安装docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ sudo apt -y update</span><br><span class="line">[mint@ali-mint ~]$ sudo apt -y install docker.io</span><br><span class="line">[mint@ali-mint ~]$ sudo service docker.io restart</span><br><span class="line">[mint@ali-mint ~]$ sduo service docker.io status</span><br><span class="line">[mint@ali-mint ~]$ sudo dpkg-qurey -L docker.io | less</span><br></pre></td></tr></table></figure>

<h3 id="搭建Docker-Registry"><a href="#搭建Docker-Registry" class="headerlink" title="搭建Docker Registry"></a>搭建Docker Registry</h3><p>如果没有网络的环境下怎么使用docker拉取镜像呢，这就需要提前构建docker私有registry。并且还可以减少pull、push的时间。基于Centos7系统可以使用yum安装docker-registry包来部署docker registry。注意需要开放防火墙访问权限或者直接关闭防火墙。</p>
<h4 id="安装docker-registry"><a href="#安装docker-registry" class="headerlink" title="安装docker-registry"></a>安装docker-registry</h4><h5 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# yum -y install docker-registry</span><br><span class="line">[root@docker-registry ~]# systemctl restart docker-distribution</span><br><span class="line">[root@docker-registry ~]# systemctl enable docker-distribution</span><br><span class="line">[root@docker-registry ~]# netstat -tnlp|grep registry</span><br><span class="line">tcp6       0      0 :::5000                 :::*                    LISTEN      2703/registry</span><br></pre></td></tr></table></figure>

<h5 id="使用docker容器部署"><a href="#使用docker容器部署" class="headerlink" title="使用docker容器部署"></a>使用docker容器部署</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker run -d 5000:5000 registry</span><br></pre></td></tr></table></figure>

<h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry yum.repos.d]# docker run --name myhello hello-world</span><br></pre></td></tr></table></figure>

<h4 id="允许访问registry"><a href="#允许访问registry" class="headerlink" title="允许访问registry"></a>允许访问registry</h4><p>Docker客户端要求从registry那里获得证书，或者将registry标记为不安全。可以通过编辑/etc/sysconfig/docker文件将registry标记为不安全，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# cat !$</span><br><span class="line">cat /etc/sysconfig/docker</span><br><span class="line">ADD_REGISTRY='--add-registry localhost:5000'</span><br><span class="line">INSECURE_REGISTRY='--insecure-registry loclahost:5000'</span><br><span class="line">[root@docker-registry ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="为镜像打个标签"><a href="#为镜像打个标签" class="headerlink" title="为镜像打个标签"></a>为镜像打个标签</h4><p>使用docker tag命令为镜像指定一个名字，之后可以使用这个名字把镜像推送到本地的docker registry中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker tag hello-world localhost:5000/hello-world-me</span><br></pre></td></tr></table></figure>

<h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>将hello-world-me镜像推送到docker-registry中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker push localhost:5000/hello-world-me</span><br></pre></td></tr></table></figure>

<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>为了确保从本地registry中拉取镜像，需要删除本地镜像，然后尝试从本地registry中取回该镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker rmi myhello</span><br><span class="line">[root@docker-registry ~]# docker rmi hello-world localhost:5000/hello-world</span><br><span class="line">[root@docker-registry ~]# docker pull localhost:5000/hello-world-me</span><br><span class="line">[root@docker-registry ~]# docker images</span><br></pre></td></tr></table></figure>

<h4 id="配置私有Docker-Registry仓库"><a href="#配置私有Docker-Registry仓库" class="headerlink" title="配置私有Docker Registry仓库"></a>配置私有Docker Registry仓库</h4><ul>
<li>–access-logfile：对docker-registry服务的访问记录会记录到所设置的任何文件</li>
<li>–max-requests 100：设置registry守护进程能够接收的请求上限为100</li>
<li>–graceful-timeout 3600：工作进程发起重启信号后，在给3600s来完成正在处理的请求。如果这段时间不能处理完，则会被杀死</li>
<li>-t 3600：工作进程超过3600s(1小时)没有活动，他会被杀死并重启。</li>
<li>-k gevent：将工作进程类型设置为gevent（基于Greenlets的一种异步工作进程）</li>
<li>-b 0.0.0.0:5000：将工作进程绑定到系统所在IP地址（0.0.0.0）的5000端口上，此时外部docker客户端可以使用tcp5000端口连接到docker registry</li>
<li>-w 4：设置工作进程为4</li>
<li>docker_registry.wsgi:application：进程随Docker registry wsgi应用程序一起运行</li>
</ul>
<h3 id="运行容器镜像"><a href="#运行容器镜像" class="headerlink" title="运行容器镜像"></a>运行容器镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run centos cat /etc/os-release</span><br><span class="line">NAME="CentOS Linux"</span><br><span class="line">VERSION="7 (Core)"</span><br><span class="line">ID="centos"</span><br><span class="line">ID_LIKE="rhel fedora"</span><br><span class="line">VERSION_ID="7"</span><br><span class="line">PRETTY_NAME="CentOS Linux 7 (Core)"</span><br><span class="line">ANSI_COLOR="0;31"</span><br><span class="line">CPE_NAME="cpe:/o:centos:centos:7"</span><br><span class="line">HOME_URL="https://www.centos.org/"</span><br><span class="line">BUG_REPORT_URL="https://bugs.centos.org/"</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT="CentOS-7"</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION="7"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT="centos"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION="7"</span><br></pre></td></tr></table></figure>

<p>执行以上docker run centos cat /etc/os-release命令则docker引擎会进行以下操作 </p>
<ul>
<li>寻找镜像: 到centos:latest的镜像，本地仓库没有则会到Docker.io的registry查找，并下载centos:lateset</li>
<li>执行命令: cat命令会显示出/etc/os-release文件的内容</li>
</ul>
<p>以上命令执行只是打印/etc/os-release文件的内容，打印完就执行完了。可以使用docker images查看本地系统的镜像，docker ps查看正在运行的容器，docker ps -a查看所有容器，如果需要重新启动该容器，则需要使用docker start命令启动容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">fedora              latest              ef49352c9c21        11 days ago         246MB</span><br><span class="line">ubuntu              latest              3556258649b2        2 weeks ago         64.2MB</span><br><span class="line">centos              latest              9f38484d220f        5 months ago        202MB</span><br><span class="line">[mint@ali-mint ~]$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">12572b653b36        centos              "cat /etc/os-release"   16 minutes ago      Exited (0) 16 minutes ago                       upbeat_noyce</span><br><span class="line">[mint@ali-mint ~]$ docker start -i 12572b653b36</span><br><span class="line">NAME="CentOS Linux"</span><br><span class="line">VERSION="7 (Core)"</span><br><span class="line">ID="centos"</span><br><span class="line">ID_LIKE="rhel fedora"</span><br><span class="line">VERSION_ID="7"</span><br><span class="line">PRETTY_NAME="CentOS Linux 7 (Core)"</span><br><span class="line">ANSI_COLOR="0;31"</span><br><span class="line">CPE_NAME="cpe:/o:centos:centos:7"</span><br><span class="line">HOME_URL="https://www.centos.org/"</span><br><span class="line">BUG_REPORT_URL="https://bugs.centos.org/"</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT="CentOS-7"</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION="7"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT="centos"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION="7"</span><br></pre></td></tr></table></figure>

<p>此时使用docker start -i 12572b653b36，-i 选项把容器的输出定向到本地shell中</p>
<h4 id="以交互式运行容器镜像"><a href="#以交互式运行容器镜像" class="headerlink" title="以交互式运行容器镜像"></a>以交互式运行容器镜像</h4><p>常见的例子，打开一个shell在容器内部直接进行操作。可以方便查看容器内部情况并修改内容。以下我通过执行/bin/bash命令打开一个容器的shell进行交互</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it centos /bin/bash</span><br><span class="line">[root@10962ad1fb5c /]#</span><br><span class="line">[root@10962ad1fb5c /]# ps -e</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 bash</span><br><span class="line">   14 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>此时已经来到容器内部了，可以通过主机名来看，如果主机名没有变化，可以通过执行ps -e命令来查看正在运行的命令来判断。</p>
<p>也可以在容器中执行命令，使用yum命令添加更多程序到容器中。可以使用exit退出容器shell，还可以通过docker commit命令制作新的镜像，需要使用docker ps -a查询到该容器的容器ID,本地系统就有一个名为testrun的镜像了并可以为接下来的docker run做准备</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@10962ad1fb5c /]# yum -y install httpd vsftpd httpd-manual net-tools iproute</span><br><span class="line">[root@10962ad1fb5c /] exit</span><br><span class="line">[mint@ali-mint ~]$ docker commit 10962ad1fb5c testrun</span><br><span class="line">sha256:b38aa80475139935155a341257cb03f4b7cf6279f2a93b509d6a8daab60b8578z</span><br><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">testrun             latest              b38aa8047513        About a minute ago   356MB</span><br></pre></td></tr></table></figure>

<h4 id="在容器内运行管理命令"><a href="#在容器内运行管理命令" class="headerlink" title="在容器内运行管理命令"></a>在容器内运行管理命令</h4><p>想在运行容器之后结束后，容器自动销毁，可以添加–rm选项。这样就不会有太多无用容器占用磁盘空间。执行ip和route命令依赖于之前安装的net-tools和iproute命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it --rm testrun /usr/sbin/ip addr show eth0</span><br><span class="line">266: eth0@if267: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[mint@ali-mint ~]$ docker run -it --rm testrun /usr/sbin/route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.18.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line">[mint@ali-mint ~]$ ip addr show docker0</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:29:b8:4b:2f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>前两个docker命令查询到容器内的网络情况，接下来的IP命令显示了宿主机的docker0网络接口，它的一个IP地址172.18.0.1/16。默认情况下，宿主机会在容器启动时通过DHCP给容器分配地址。testrun运行的第一个ip地址为172.18.0.2/16。如果再次运行容器将会生成新的地址。因为通过run命令每次会生成新的容器。</p>
<p>通过route可以看到容器的默认网关是172.18.0.1，刚好是宿主机docker0网络接口的IP地址。通过宿主机的docker0接口进行路由能够让容器访问本地宿主机之外的网络资源</p>
<h4 id="运行容器化服务"><a href="#运行容器化服务" class="headerlink" title="运行容器化服务"></a>运行容器化服务</h4><p>使用容器运行服务由以下优势：</p>
<ul>
<li>配置：能够提前配置好所需的全部可执行程序，库，配置文件等无需担心宿主机是否提供这些组件，还方便将容器迁移至另一台服务器</li>
<li>隔离：每个容器都有自己的文件系统和网络接口，所以能够运行多个相同的服务容器</li>
</ul>
<p>使用docker简单构件apache web服务器，apache会默认监听80和443端口。首先创建宿主机目录，添加index.html文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ mkdir /var/www/html/</span><br><span class="line">[mint@ali-mint ~]$ cat  /var/www/html/index.html                                 </span><br><span class="line">The Apache Web Server is Running!</span><br></pre></td></tr></table></figure>

<p>使用之前构建的testrun镜像，执行以下命令前确保宿主机的80和443没有被占用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 80:80 -p 443:443 --name=MyWebServer -v /var/www/:/var/www/ testrun /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">da04638d9afc285111bd0eb51c4e73b0651c3e73ab14af997fb9f31e46cd6fe0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选线</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>让容器化命令在后台运行容器</td>
</tr>
<tr>
<td>-p 80:80 -p 443:443</td>
<td>映射端口，将容器端口映射到宿主机的端口上，冒号左边是宿主机端口，右边是容器端口。这里是将容器的80和443端口分别映射到宿主机的80和443端口上</td>
</tr>
<tr>
<td>–name=MyWebServer</td>
<td>指定容器名，之后可以通过容器名来操作容器，而不用通过难记的容器ID操作</td>
</tr>
<tr>
<td>-v /var/www:/var/www</td>
<td>挂载卷，将宿主机（冒号左边）的目录挂载到容器（冒号右边）的目录</td>
</tr>
<tr>
<td>testrun</td>
<td>镜像名称</td>
</tr>
<tr>
<td>/usr/sbin/httpd -DFOREGROUND</td>
<td>使用-DFOREGROUND选项来运行httpd守护进程</td>
</tr>
</tbody></table>
<p>此时使用docker ps可以看到该容器，看到容器被分配了容器ID，使用的镜像testrun，运行的命令是httpd，容器是在11分钟之前创建的，宿主机上所有IPv4的网络接口将会对80和443端口的请求转发到容器内对应的端口上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES</span><br><span class="line">da04638d9afc        testrun             "/usr/sbin/httpd -DF…"   11 minutes ago      Up 11 minutes       0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   MyWebServer</span><br></pre></td></tr></table></figure>

<p>也可以使用docker exec进入容器，按exit退出容器。</p>
<p>因为容器的80端口已经映射到宿主机的80上，所以通过访问宿主机的80端口即可访问到文件/var/www/html/index.html的内容。因为安装过httpd-manual包。所以还可以通过浏览器访问宿主机地址的80端口下的/manual页面可以访问到httpd的manual页</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker exec -it MyWebServer /bin/bash </span><br><span class="line">[root@da04638d9afc /]# exit</span><br><span class="line">exit</span><br><span class="line">[mint@ali-mint ~]$ curl localhost</span><br><span class="line">The Apache Web Server is Running!</span><br></pre></td></tr></table></figure>

<h4 id="在容器中运行服务时进行资源限制"><a href="#在容器中运行服务时进行资源限制" class="headerlink" title="在容器中运行服务时进行资源限制"></a>在容器中运行服务时进行资源限制</h4><p>默认情况下，容器运行时，容器访问内存、CPU方面是没有限制的，可以使用–memory、–momory-swap、–cpu-shares和–cpuset-cpus选项来限制可以使用的内存和CPU。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 80:80 -p 443:443 --name=MyWebServer -v /var/www/:/var/www/ --memory=10m --memory-swap=-1 --cpu-shares=256 testrun /usr/sbin/httpd -DFOREGROUND ec5e1a8281f0f8406187431f1eb3a5b46e864ab85adf2aadc8c5eddc1698a8fb</span><br></pre></td></tr></table></figure>

<ul>
<li>–memory=10m：容器可以使用10m的内存</li>
<li>–memory-swap=-1：容器可以无限制使用交换空间，如果不设置默认为memory的2倍（20m）</li>
<li>–cpu-shares=256： 在1024范围内设置CPU配额。设置256只占1024的25%</li>
<li>–cpuset-cpus=0,1：使用CPU核0或1</li>
<li>–cpuset-cpus=3：使用第四个CPU核</li>
<li>–cpuset-cpus=1-3：使用CPU核1，2或3</li>
</ul>
<h4 id="运行特权容器"><a href="#运行特权容器" class="headerlink" title="运行特权容器"></a>运行特权容器</h4><p>大多数情况下，运行docker容器时，会限制访问宿主机或其他容器的访问以及其他容器访问我正在运行的容器。然而有些特殊情况下，想要让容器拥有更大的宿主机系统访问权限。这种容器就成为特权容器</p>
<table>
<thead>
<tr>
<th>选线</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–ipc</td>
<td>IPC：开放访宿主机的进程间通信设施。默认情况下，每个容器都有私有的IPC功能设施</td>
</tr>
<tr>
<td>–net-host</td>
<td>网络接口：向容器开放宿主机的网路接口。容器默认都有自己的网络接口</td>
</tr>
<tr>
<td>–pid=host</td>
<td>进程表：允许容器访问进程表。容器默认有自己的进程表</td>
</tr>
<tr>
<td>-e HOST=/host</td>
<td>宿主机文件系统：如果设置了，HOST环境变量会告诉容器将宿主机的root文件系统挂载到容器的某个目录上，推荐挂载在/host下</td>
</tr>
<tr>
<td>–privileged</td>
<td>这一选项会关闭容器运行命令的安全隔离。因此，以root运行的进程拥有宿主机上以root运行任何进程是同样的权限</td>
</tr>
</tbody></table>
<h3 id="查找、拉取、保存和装载容器镜像"><a href="#查找、拉取、保存和装载容器镜像" class="headerlink" title="查找、拉取、保存和装载容器镜像"></a>查找、拉取、保存和装载容器镜像</h3><h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><p>使用docker search命令搜索镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker search centos</span><br><span class="line">[mint@ali-mint ~]$ docker search ubuntu</span><br><span class="line">[mint@ali-mint ~]$ docker search nginx</span><br><span class="line">[mint@ali-mint ~]$ docker search mysql</span><br><span class="line">[mint@ali-mint ~]$ docker search jenkins</span><br></pre></td></tr></table></figure>

<p>也可以细化搜索</p>
<ul>
<li>-s：查找star数至少是多少的</li>
<li>–no-trunc：告诉docker search不要截取描述字段</li>
<li>automated=true：只显示定期自动重新构建的镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker search -s 100 centos</span><br><span class="line">[mint@ali-mint ~]$ docker search --no-trunc=true mysql</span><br><span class="line">[mint@ali-mint ~]$ docker search --automated=true centos</span><br></pre></td></tr></table></figure>

<h4 id="在Docker-Hub上检索镜像"><a href="#在Docker-Hub上检索镜像" class="headerlink" title="在Docker Hub上检索镜像"></a>在Docker Hub上检索镜像</h4><p>通过web浏览器访问<a href="https://registry.hub.docker.com/" target="_blank" rel="noopener">Docker Hub Registry</a>，可以找到镜像的很多信息。如果需要查找多个镜像的文档，可以访问<a href="https://github.com/docker-library/doc" target="_blank" rel="noopener">Docker Library</a>，找到相应镜像并查看其文档</p>
<ul>
<li>支持的镜像版本</li>
<li>用来运行镜像的基本docke run命令</li>
<li>配合docker run使用环境变量，这些变量可以更改镜像设置</li>
<li>这个容器镜像在github页面的位置</li>
<li>用于构建该镜像的Dockerfile文件</li>
</ul>
<h4 id="从Docker-Registry上拉取镜像"><a href="#从Docker-Registry上拉取镜像" class="headerlink" title="从Docker Registry上拉取镜像"></a>从Docker Registry上拉取镜像</h4><p>通过docker pull命令可以从docker registry上拉取镜像，可以从Docker Hub Registry上拉取，也可以从自建的docker registry上拉取。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker pull centos</span><br><span class="line">[mint@ali-mint ~]$ docker pull mysql</span><br><span class="line">[mint@ali-mint ~]$ docker pull nginx</span><br><span class="line">[mint@ali-mint ~]$ docker pull 172.16.100.10:5000/centos</span><br><span class="line">[mint@ali-mint ~]$ docker pull 172.16.100.10:5000/mysql</span><br><span class="line">[mint@ali-mint ~]$ docker pull 172.16.100.10:5000/nginx</span><br></pre></td></tr></table></figure>

<h4 id="保存和装载镜像"><a href="#保存和装载镜像" class="headerlink" title="保存和装载镜像"></a>保存和装载镜像</h4><p>拉取镜像并不是将镜像放入Docker的唯一方式，还可以把镜像保存为tarball，然后copy到其他系统中，并装载它。</p>
<p>以下使用docker save命令将centos进行保存为一个tarball。tarball文件都包含了要构成保存镜像所需要的层，再将tar拷贝到另一个运行Docker服务的系统后，可使用docker load命令装载它并查看结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker save -o centos7.tar centos</span><br><span class="line">[mint@ali-mint ~]$ scp centos7.tar 172.18.9.50:/tmp</span><br><span class="line">[test@test ~]$ docker load -i /tmp/centos7.tar</span><br><span class="line">[test@test ~]$ docker images|grep centos</span><br></pre></td></tr></table></figure>

<h3 id="为镜像做标签"><a href="#为镜像做标签" class="headerlink" title="为镜像做标签"></a>为镜像做标签</h3><h3 id="检视容器"><a href="#检视容器" class="headerlink" title="检视容器"></a>检视容器</h3><p>每个镜像所附带的信息包含了默认配置、创建者信息以及何时以何种方式创建的细节。在容器运行后，容器会包含额外的信息，如容器的网络配置、容器是否正在运行以及挂载卷的信息。</p>
<p>在容器或镜像上运行docker inspect命令可以查看与之关联的底层数据。在用镜像或容器调试问题时，很有帮助。例如查看容器IP地址可以了解客户端程序（Web浏览器）去哪里寻找容器中运行的服务。docker inspect采用json格式显示，方便阅读。</p>
<h4 id="用docker-inspect检视基础镜像"><a href="#用docker-inspect检视基础镜像" class="headerlink" title="用docker inspect检视基础镜像"></a>用docker inspect检视基础镜像</h4><p>通过检视镜像可以大致了解到镜像的创建时间、构建镜像使用的Docker版本，对外开放的端口等信息。以下例子检视了最新的centos镜像。倘若centos:latest尚未拉取到我的本地系统，该命令会先拉取对应镜像并检视它。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect centos</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line"> 		"Architecture": "amd64",</span><br><span class="line">        "Author": "",</span><br><span class="line">		"Comment": "",</span><br><span class="line">		"Config": &#123;</span><br><span class="line">            "AttachStdin": false,</span><br><span class="line">            "AttachStdout": false,</span><br><span class="line">            "AttachStderr": false,</span><br><span class="line">			"Cmd": [</span><br><span class="line">                "/bin/sh",</span><br><span class="line">                "-c",</span><br><span class="line">                "#(nop) ",</span><br><span class="line">                "CMD [\"/bin/bash\"]"</span><br><span class="line">            ],			</span><br><span class="line">			"Env": [</span><br><span class="line">                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span><br><span class="line">            ],</span><br><span class="line">	...</span><br><span class="line">		"Created": "2019-03-14T21:19:53.361167852Z",</span><br><span class="line">        "DockerVersion": "18.06.1-ce",</span><br><span class="line">        "Id": "sha256:9f38484d220fa527b1fb19747638497179500a1bed8bf0498eb788229229e6e1",</span><br><span class="line">        "Os": "linux",</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>从这些输出可以看出很多信息。该容器体系结构是amd64的，兼容64PC机。该镜像创建时没有定义Comment和Author。Config部分设置了容器运行的环境。</p>
<p>如果运行时没有指定其他命令，默认会运行/bin/bash命令。由于与标准输入、标准输出和标准错误的关联被设置为false。因此在运行该容器时要指定一些选项（docker run -it centos）。Env设置了PATH变量，定义了运行命令是用于查找命令的目录。最后一部分显示了和容器创建相关的基本信息。如创建时间，创建容器的docker版本，完整的容器ID以及是何种操作系统。</p>
<h4 id="查看镜像历史"><a href="#查看镜像历史" class="headerlink" title="查看镜像历史"></a>查看镜像历史</h4><p>可以在基础镜像是上构建生成新镜像。每次在镜像上运行新命令。就会长生一个新的容器层。如果这些层与镜像保存在一起就可以使用docker history命令查看这些信息。</p>
<p>要查看镜像历史，只要该镜像上执行docker history命令即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker history centos</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">9f38484d220f        5 months ago        /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B                  </span><br><span class="line">&lt;missing&gt;           5 months ago        /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B                  </span><br><span class="line">&lt;missing&gt;           5 months ago        /bin/sh -c #(nop) ADD file:074f2c974463ab38c…   202MB</span><br></pre></td></tr></table></figure>

<p>可以看到，镜像是5个月前构建的，并修改了3次，还可以看到生成镜像的shell命令。之后容器如果使用了IMAGE列的任何镜像层，就不必在拉去那个层，而只要使用系统中已经存在的这个层就可以了。</p>
<h4 id="检视正在运行的容器"><a href="#检视正在运行的容器" class="headerlink" title="检视正在运行的容器"></a>检视正在运行的容器</h4><p>一旦容器运行起来，不但可以获得原始镜像的信息还可以获得docker run命令所设置的许多数据，以及它在运行时添加到容器的配置设置。只要docker ps -a能列出来的容器，都可以用docker inspect来查看</p>
<h5 id="启动要检视的容器"><a href="#启动要检视的容器" class="headerlink" title="启动要检视的容器"></a>启动要检视的容器</h5><p>以下例子使用centos镜像通过python命令和SimpleHTTPServer组件运行一个简单的Web服务器。Web服务器以守护进程（-d）的方式在后台运行，并且容器的8080端口开放给宿主机，容器名字为centos_web，通过设置–restart=”on-failure:5”当容器发生故障时，docker会至多尝试5次来重启容器。默认不会自动重启，初始镜像是centos，用python2运行SimpleHTTPServer模块来让8080端口提供服务。可以通过在宿主机上执行命令curl localhost:8080 容器是否在运行，可以发现在容器中和在宿主机上执行该命令输出结果都一致。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ali-mint ~]# echo "Start Python Web Server on Centos: Successful" &gt; /var/www/html/index.html</span><br><span class="line">[root@ali-mint ~]# docker run -d -p 8080:8080 --name="centos_web" --restart="on-failure:5" -w /var/www/html/ -v /var/www/html/:/var/www/html/ centos python -m SimpleHTTPServer 8080</span><br><span class="line">7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd</span><br><span class="line">[root@ali-mint ~]# docker exec -it 7544f6d77f30 /bin/bash</span><br><span class="line">[root@7544f6d77f30 html]# curl localhost:8080</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br><span class="line">[root@ali-mint ~]# curl localhost:8080</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<h5 id="检视整个容器配置"><a href="#检视整个容器配置" class="headerlink" title="检视整个容器配置"></a>检视整个容器配置</h5><p>使用docker inspect命令可以直接输出该容器的全部信息，当然也可以通过使用管道、重定向将内容送到more、less或文件上以便阅读。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ali-mint mint]# docker inspect centos_web</span><br><span class="line">	...</span><br><span class="line">        "Args": [</span><br><span class="line">            "-m",</span><br><span class="line">            "SimpleHTTPServer",</span><br><span class="line">            "8080"</span><br><span class="line">        ],</span><br><span class="line">        "Config": &#123;</span><br><span class="line">            "AttachStdin": false,</span><br><span class="line">            "AttachStdout": false,</span><br><span class="line">            "AttachStderr": false,</span><br><span class="line">            "Cmd": [</span><br><span class="line">                "python",</span><br><span class="line">                "-m",</span><br><span class="line">                "SimpleHTTPServer",</span><br><span class="line">                "8080"</span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>

<p>属性Arg中保存了容器启动是传给python命令的3个参数。Config部分显示标准错误、标准输入和标准输出并关联到启动容器的终端会话上。如果要运行/bin/bash，以便通过终端控制台直接与容器交互，这些设置应该设置为true，而不是false。Config部分的Cmd属性存放了命令（Python）及传给该命令的所有参数（-m、SimpleHTTPServer和8080）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">		"Hostname": "7544f6d77f30",</span><br><span class="line">		"CpuShares": 0,</span><br><span class="line">		"CpusetCpus": "",</span><br><span class="line">...</span><br><span class="line"> 		"ExposedPorts": &#123;</span><br><span class="line">              "8080/tcp": &#123;&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">     		"Tty": false,</span><br><span class="line">          "OpenStdin": false,</span><br><span class="line">          "StdinOnce": false,</span><br><span class="line">          "Env": [</span><br><span class="line">              "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span><br><span class="line">          ],</span><br></pre></td></tr></table></figure>

<p>如果系统中存在多个容器，也许想要为每个容器分配CPU配额，以确保重要的容器获得更高比例的CPU时间，此处，CpusShares并未获取到CPU的优先级。如果设定了CpusetCpus，容器只会在选中的CPU上运行。这两个值都可以通过docker run命令的-c和–cpuset-cpus=””选项设置.</p>
<p>Env部分包含了PATH的设置，PATH定义了在容器中执行命令时用来查找命令的目录。ExposedPorts显示容器TCP8080端口开放到宿主机的相同端口上。由于命令行中没有设置主机名，容器的前12个字符被用作主机名。可以使用docker run的-h选项为容器分配主机名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">		"Image": "centos",</span><br><span class="line">...</span><br><span class="line">		"User": "",</span><br><span class="line">...</span><br><span class="line">		"WorkingDir": "/var/www/html",</span><br><span class="line">	],</span><br></pre></td></tr></table></figure>

<p>Images显示使用的镜像名称（centos），User没有设置，如设置则容器内的命令会使用指定的用户运行。例如，docker run命令设置-u aapache选项，Web服务器会以apache用户运行，而不是root用户。WorkingDir设置工作目录（命令执行的目录）设置为/var/www/html。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">"HostConfig": &#123;</span><br><span class="line">		...</span><br><span class="line">           "PortBindings": &#123;</span><br><span class="line">               "8080/tcp": [</span><br><span class="line">                   &#123;</span><br><span class="line">                       "HostIp": "",</span><br><span class="line">                       "HostPort": "8080"</span><br><span class="line">                   &#125;</span><br><span class="line">               ]</span><br><span class="line">           &#125;,</span><br><span class="line">           "Privileged": false,</span><br><span class="line">           "PublishAllPorts": false,</span><br><span class="line">           "ReadonlyRootfs": false,</span><br><span class="line">           "RestartPolicy": &#123;</span><br><span class="line">               "Name": "on-failure",</span><br><span class="line">               "MaximumRetryCount": 5</span><br><span class="line">           &#125;,</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>PortBindings设置了TCP8080端口对宿主机上所有IP地址的8080端口开放。Privileged: false表示容器除了额外指定的方式（如明确的从宿主机挂载卷）之外，没有权限访问其他容器或者宿主机。当PublishAllPorts设置为false时，容器中只有那些明确指定的端口（此处的8080）才能被宿主机相同的端口访问到。ReaadonlyRootfs设置为false。则root文件系统可以被写入。RestartPolicy默认属性如果发生故障不重启，本例会重启5次</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"Id": "7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd",</span><br><span class="line">"Image": "sha256:9f38484d220fa527b1fb19747638497179500a1bed8bf0498eb788229229e6e1",</span><br><span class="line">"Name": "/centos_web",</span><br><span class="line">"MountLabel": "",</span><br><span class="line">"HostnamePath": "/var/lib/docker/containers/7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd/hostname",   </span><br><span class="line">"HostsPath": "/var/lib/docker/containers/7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd/hosts",</span><br><span class="line">"LogPath": "/var/lib/docker/containers/7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd/7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd-json.log",</span><br></pre></td></tr></table></figure>

<p>HostnamePath设置了容器/etc/hostname文件的位置。HostPath设置了容器/etc/hosts文件的位置，该文件将容器的主机名和IP地址关联到一起，同时还设置了localhost的IP地址以及IPV6地址。LogPath设定了与该容器关联的日志文件位置，文件名是容器ID-json.log。可以使用docker logs centos_web查看容器日志。MountLabel设置了selinux的上下文。Name属性的内容是斜杠加上容器名(/centos_web)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">"NetworkSettings": &#123;</span><br><span class="line">            "Bridge": "",</span><br><span class="line">            "Gateway": "172.18.0.1",</span><br><span class="line">            "GlobalIPv6Address": "",</span><br><span class="line">            "GlobalIPv6PrefixLen": 0,</span><br><span class="line">            "IPAddress": "172.18.0.2",</span><br><span class="line">            "IPPrefixLen": 16,</span><br><span class="line">            "IPv6Gateway": "",</span><br><span class="line">            "LinkLocalIPv6Address": "",</span><br><span class="line">            "LinkLocalIPv6PrefixLen": 0,</span><br><span class="line">            "MacAddress": "02:42:ac:12:00:02",</span><br><span class="line">            "Ports": &#123;</span><br><span class="line">                "8080/tcp": [</span><br><span class="line">                    &#123;</span><br><span class="line">                        "HostIp": "0.0.0.0",</span><br><span class="line">                        "HostPort": "8080"</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>

<p>Bridge设定了网络名称（默认docker0），该网络为宿主机上的Docker容器提供了网络接口。宿主机IP地址是172.18.0.2，Docker默认不启用IPV6。MacAddress指定了容器内虚拟网卡的地址。Ports设定显示了TCP8080端口到宿主机上所有IP地址（0.0.0.0）以及TCP8080端口的分配。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">"State": &#123;</span><br><span class="line">    "Status": "running",</span><br><span class="line">    "Running": true,</span><br><span class="line">    "Paused": false,</span><br><span class="line">    "Restarting": false,</span><br><span class="line">    "OOMKilled": false,</span><br><span class="line">    "Dead": false,</span><br><span class="line">    "Pid": 13298,</span><br><span class="line">    "ExitCode": 0,</span><br><span class="line">    "Error": "",</span><br><span class="line">    "StartedAt": "2019-08-15T10:00:10.428661642Z",</span><br><span class="line">    "FinishedAt": "0001-01-01T00:00:00Z"</span><br><span class="line">&#125;,</span><br><span class="line"> "Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        "Type": "bind",</span><br><span class="line">        "Source": "/var/www/html",</span><br><span class="line">        "Destination": "/var/www/html",</span><br><span class="line">        "Mode": "",</span><br><span class="line">        "RW": true,</span><br><span class="line">        "Propagation": "rprivate"</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>state属性提供了容器当前状态的信息。由于容器正在运行，所以Running为true。Mounts属性可以查看到被挂载的目录（源目录）是宿主机的/var/www/html。挂载到的目录（目的目录）是容器的/var/www/html，RW为true表示可读可写。</p>
<h5 id="检视单个容器的属性"><a href="#检视单个容器的属性" class="headerlink" title="检视单个容器的属性"></a>检视单个容器的属性</h5><p>可以通过docker inspect命令的–format选项指定希望查询到的具体属性。不但可以获取容器的特定信息，还可以将这些信息传递给其他命令。可以把查询结果传给ping命令。也可以用curl命令来接收查询的内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect --format="&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;" centos_web</span><br><span class="line">172.18.0.2</span><br><span class="line"></span><br><span class="line">[mint@ali-mint ~]$ ping -c 4 `docker inspect --format="&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;" centos_web`</span><br><span class="line">PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.078 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.076 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.073 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=4 ttl=64 time=0.077 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.2 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.073/0.076/0.078/0.002 ms</span><br><span class="line"></span><br><span class="line">[mint@ali-mint ~]$ curl -L  `docker inspect --format="&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;" centos_web`:8080</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<h5 id="检视运行终端会话的容器"><a href="#检视运行终端会话的容器" class="headerlink" title="检视运行终端会话的容器"></a>检视运行终端会话的容器</h5><p>当启动容器是运行在shell终端会话时，可以通过另外的shell来检视该容器，只要该容器将标准输入STDIN、标准输出STDOUT、标准错误STDERR关联到这个shell。在Docker宿主机上打开两个shell会话，在第一个shell下输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it --name=bashtest centos /bin/bash</span><br><span class="line">[root@62a9c8da90a3 /]# ls</span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p>启动bashtest后，打开一个新的shell并检视第一个shell与容器标准输入、标准输出和标准错误关联配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect --format='&#123;&#123;.Config.AttachStdin&#125;&#125; &#123;&#123;.Config.AttachStdout&#125;&#125; &#123;&#123;.Config.AttachStderr&#125;&#125;' bashtest </span><br><span class="line">true true true</span><br></pre></td></tr></table></figure>

<p>如果想查看最初启动容器的shell，或者与其交互，可以使用docker attach 命令。在第二个shell中，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker attach bashtest</span><br></pre></td></tr></table></figure>

<p>此时可以发现在这两个shell下，不论其中一个输入什么，另一个都会一样的显示。</p>
<h5 id="检视容器的内存和CPU限制"><a href="#检视容器的内存和CPU限制" class="headerlink" title="检视容器的内存和CPU限制"></a>检视容器的内存和CPU限制</h5><p>如果Docker服务器上使用很多容器，并且多个容器之间存在交互，就存在容器之前争夺资源的问题。通过docker run可以限制某个容器可以使用的内存和交换区数量。还可以为容器设置CPU优先级并限制CPU的使用。</p>
<p>默认运行容器并不会对限制这些资源。添加以下选项重新运行centos_web</p>
<ul>
<li>–cpuset-cpus=0：设置系统的第一个CPU执行来自容器的命令</li>
<li>–cpu-shares=256：设置容器能得到的CPU时钟周期的比例为25%</li>
<li>–memory=512M：限制容器能够使用的内存数量为512M</li>
<li>–memory-swap=2G：限制容器使用的交换分区大小为2G</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 8080:8080 --name=centos_web  --cpuset-cpus=0 --cpu-shares=256 --memory=512M --memory-swap=2G --restart="on-failure:5" -w /var/www/html -v /var/www/html:/var/www/html centos python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>

<p>可以逐个检视以上配置是否生效。以下输出可以看出容器被设置使用Docker服务器的第一个CPU（0）。容器的CpuShares设置为512，默认1024。内存限制为512M。交换分区2G。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect --format='&#123;&#123;.HostConfig.CpusetCpus&#125;&#125;' centos_web</span><br><span class="line">0</span><br><span class="line">[mint@ali-mint ~]$ docker inspect --format='&#123;&#123;.HostConfig.CpuShares&#125;&#125;' centos_web       </span><br><span class="line">256</span><br><span class="line">[mint@ali-mint ~]$ docker inspect --format='&#123;&#123;.HostConfig.Memory&#125;&#125;' centos_web         </span><br><span class="line">536870912</span><br><span class="line">(base) [mint@ali-mint ~]$ docker inspect --format='&#123;&#123;.HostConfig.MemorySwap&#125;&#125;' centos_web</span><br><span class="line">2147483648</span><br></pre></td></tr></table></figure>

<h4 id="寻找探查容器的其他方法"><a href="#寻找探查容器的其他方法" class="headerlink" title="寻找探查容器的其他方法"></a>寻找探查容器的其他方法</h4><h5 id="使用docker-top查看进程"><a href="#使用docker-top查看进程" class="headerlink" title="使用docker top查看进程"></a>使用docker top查看进程</h5><p>一个容器通常只运行一个进程，然而使用docker exec可以在容器中运行其他进程。使用docker top可以查看容器中正在运行的所有进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker top centos_web</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                16548               16532               0                   23:04               ?                   00:00:00            python -m SimpleHTTPServer 8080</span><br><span class="line">root                16659               16532               0                   23:05               ?                   00:00:00            /bin/bash</span><br><span class="line">root                16698               16659               34                  23:05               ?                   00:00:02            /usr/bin/python /usr/bin/yum -y install vim</span><br></pre></td></tr></table></figure>

<h5 id="使用docker-attach与容器内服务进行交互"><a href="#使用docker-attach与容器内服务进行交互" class="headerlink" title="使用docker attach与容器内服务进行交互"></a>使用docker attach与容器内服务进行交互</h5><p>使用docker attach可以关联到任何正在运行的容器。之前创建的centos_web，连接进去，观察Web服务器对接收的请求的响应。访问宿主机8080端口或者centos_web的8080端口，在访问一个不存在的页面。可看到如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker attach centos_web</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:24] "GET / HTTP/1.1" 200 -</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:25] "GET / HTTP/1.1" 200 -</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:30] code 404, message File not found</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:30] "GET /test HTTP/1.1" 404 -</span><br></pre></td></tr></table></figure>

<h5 id="使用docker-exec在正在运行的容器中启动新进程"><a href="#使用docker-exec在正在运行的容器中启动新进程" class="headerlink" title="使用docker exec在正在运行的容器中启动新进程"></a>使用docker exec在正在运行的容器中启动新进程</h5><p>使用docker exec在容器中执行yum 安装net-tools包，并查看容器默认网关172.18.0.1（宿主机docker0网口IP地址）、监听的端口等信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker exec -it centos_web yum -y install net-tools </span><br><span class="line">  Installing : net-tools-2.0-0.24.20131004git.el7.x86                1/1 </span><br><span class="line">  Verifying  : net-tools-2.0-0.24.20131004git.el7.x86_64             1/1 </span><br><span class="line">Installed:</span><br><span class="line">  net-tools.x86_64 0:2.0-0.24.20131004git.el7                                                                     </span><br><span class="line">Complete!</span><br><span class="line">[mint@ali-mint ~]$ docker exec -it centos_web route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.18.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line">[mint@ali-mint ~]$ docker exec -it centos_web netstat -tnlp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      1/python</span><br></pre></td></tr></table></figure>

<h5 id="使用docker-logs查看容器进程的输出"><a href="#使用docker-logs查看容器进程的输出" class="headerlink" title="使用docker logs查看容器进程的输出"></a>使用docker logs查看容器进程的输出</h5><p>不但可以使用exec、attach查看实时处理的输出，之后还可以通过docker logs查看进程处理和输出。无论运行中的容器还是已经停止的，只要是未删除的，都可以使用docker logs把容器处理的所有输出打印到屏幕上，然后退出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker logs centos_web</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:24] "GET / HTTP/1.1" 200 -</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:25] "GET / HTTP/1.1" 200 -</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:30] code 404, message File not found</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:30] "GET /test HTTP/1.1" 404 -</span><br></pre></td></tr></table></figure>

<p>输出和docker attach一致，但是docker lgos centos输出完毕后会立即退出，而docker attachb持续等待响应</p>
<h5 id="使用docker-diff查看容器的变化"><a href="#使用docker-diff查看容器的变化" class="headerlink" title="使用docker diff查看容器的变化"></a>使用docker diff查看容器的变化</h5><p>docker diff会记录容器运行后容器内文件和目录发生的所有变化。可以查看容器相对与最初运行的镜像有哪些改变。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker diff centos_web</span><br><span class="line">A /var/www</span><br><span class="line">A /var/www/html</span><br><span class="line">C /root</span><br><span class="line">C /tmp</span><br><span class="line">D /root/anaconda-ks.cfg</span><br><span class="line">A /tmp/anaconda-ks.cfg</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出显示新增了/var/www和/var/www/html目录（宿主机挂载上来的），我将/root/下的anaconda-ks.cfg移至/tmp/，导致/root/和/tmp/发生改变。还显示/root/anaconda-ks.cfg被删除，/tmp/anaconda-ks.cfg被增加。所以在提交镜像为永久镜像时，使用docker diff检查一下容器变化是极好的。</p>
<h5 id="使用docker-cp从容器复制文件"><a href="#使用docker-cp从容器复制文件" class="headerlink" title="使用docker  cp从容器复制文件"></a>使用docker  cp从容器复制文件</h5><p>有时需要拷贝容器中的文件，但又不想终止容器运行内正在进行的工作。此时就可以通过docker cp复制容器中的内容到宿主机啦</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker cp centos_web:/var/www/html/index.html /tmp/</span><br><span class="line">[mint@ali-mint ~]$ cat /tmp/index.html </span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<h3 id="容器的启动、停止和重启"><a href="#容器的启动、停止和重启" class="headerlink" title="容器的启动、停止和重启"></a>容器的启动、停止和重启</h3><h4 id="停止和启动容器"><a href="#停止和启动容器" class="headerlink" title="停止和启动容器"></a>停止和启动容器</h4><p>容器运行时，有几种不同的方式将容器暴露给宿主机系统。容器的端口可以暴露在宿主机上，容器内运行的命令可以将标准输入、标准输出和标准错误暴露给宿主机的shell会话。一旦容器停止，它就会释放资源并以某种能够重新启动的状态留存在宿主机系统中。</p>
<h5 id="启动和停止分离式容器"><a href="#启动和停止分离式容器" class="headerlink" title="启动和停止分离式容器"></a>启动和停止分离式容器</h5><p>之前制作的testrun镜像，由基础镜像并安装httpd组成。通过以下命令。我使用分离选项来启动httpd，并使容器的/var/www/目录挂载到宿主机的/var/www目录，将80端口和443端口暴露给宿主机。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]# docker run -d -p 80:80 -p 443:443 --name=WebServer -v /var/www/:/var/www/ testrun /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">9f8c5cd38768d8ff4d233eab9a2e938d2fccfc2294d8cf75b1a118b4c07b4c17</span><br><span class="line">[root@ali-mint tmp]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES</span><br><span class="line">9f8c5cd38768        testrun             "/usr/sbin/httpd -DF…"   3 seconds ago       Up 1 second         0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   WebServer    </span><br><span class="line">[mint@ali-mint ~]# netstat -tnlp|grep -E ":80|:443"</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17692/docker-proxy   </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17681/docker-proxy  </span><br><span class="line">[mint@ali-mint ~]# curl http://localhost</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<p>docke ps查看到WebServer容器正在运行。运行netstat -tnlp显示docker-proxy进程正在监听80和443端口。用curl访问显示正常的文件内容。当然停止容器只需要使用docker stop 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]# docker stop WebServer </span><br><span class="line">WebServer</span><br><span class="line">[mint@ali-mint ~]$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES</span><br><span class="line">9f8c5cd38768        testrun             "/usr/sbin/httpd -DF…"   6 minutes ago       Exited (0) 32 seconds ago                            WebServer</span><br><span class="line">[mint@ali-mint ~]$ curl http://localhost</span><br><span class="line">curl: (7) Failed to connect to localhost port 80: Connection refused</span><br></pre></td></tr></table></figure>

<p>运行docker stop后，docker ps就查不到了，但仍会出现在docker ps -a中。/usr/sbin/httpd -DFOREGROUND不再运行，而容器内容也保存在本地环境。想要启动这个容器也很简单，使用docker start即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker start WebServer</span><br><span class="line">WebServer</span><br><span class="line">[root@ali-mint tmp]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES</span><br><span class="line">9f8c5cd38768        testrun             "/usr/sbin/httpd -DF…"   3 seconds ago       Up 1 second         0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   WebServer    </span><br><span class="line">[mint@ali-mint ~]# netstat -tnlp|grep -E ":80|:443"</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17692/docker-proxy   </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17681/docker-proxy  </span><br><span class="line">[mint@ali-mint ~]# curl http://localhost</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<h5 id="启动和停止交互式容器"><a href="#启动和停止交互式容器" class="headerlink" title="启动和停止交互式容器"></a>启动和停止交互式容器</h5><p>如果容器运行的进程是交互式的，并且标准输入、标准输出和标准错误关联到宿主机的shell会话。在另一个shell上执行docker stop命令时。会话就关闭了，对打开会话的人来看就很不好</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it --name=bashubuntu ubuntu /bin/bash</span><br><span class="line">root@ec114d94181e:/# pwd</span><br><span class="line">/</span><br><span class="line">[root@ali-mint ~]$ docker stop bashubuntu</span><br><span class="line">bashubuntu</span><br></pre></td></tr></table></figure>

<p>此时发现mint用户的shell自动退出了。因为root执行了docker stop。为了使容器以交互式方式工作。添加了以下选项</p>
<ul>
<li>-a：连接选项。将终端会话连接到容器运行的bash shell的标准输出和标准错误上，这个选项可以看到bash shell的输出</li>
<li>-i：交互选项。将终端会话连接到容器运行bash shell的标准输入上，该选项可以输入命令到shell中。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker start -ai !$</span><br><span class="line">docker start -ai bashubuntu</span><br><span class="line">root@ec114d94181e:/#</span><br></pre></td></tr></table></figure>

<h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><p>可以使用docker restart直接重启容器。docker restart可以携带-t参数实现强制kill容器主进程。停止WebServer容器并重启。如果停止失败则30s之后kill该容器主进程来杀死容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker restart -t 30 WebServer</span><br><span class="line">WebServer</span><br><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES</span><br><span class="line">9f8c5cd38768        testrun             "/usr/sbin/httpd -DF…"   23 hours ago        Up About a minute   0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   WebServer</span><br></pre></td></tr></table></figure>

<h4 id="向容器发送信号"><a href="#向容器发送信号" class="headerlink" title="向容器发送信号"></a>向容器发送信号</h4><p>docker kill命令可以实现向容器内运行的主进程发送kill信号。这会立即杀死容器（包括容器内的子进程）。但是使用该命令可能会造成容器无法启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker kill WebServer</span><br><span class="line">WebServer</span><br><span class="line">(base) [mint@ali-mint ~]$ docker start WebServer</span><br><span class="line">WebServer</span><br><span class="line">(base) [mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">[mint@ali-mint ~]$ docker logs WebServer</span><br><span class="line">httpd (pid 1) already running</span><br></pre></td></tr></table></figure>

<p>杀死容器没有正常关闭，造成httpd进程虽然停止，但是没有清理进程PID文件。可以通过一下方法处理。</p>
<ul>
<li>移除该容器。并使用docker run重新启动新的容器</li>
<li>保存并修复。可以将容器打包成镜像导出为tar文件，解压tar包，修复问题（删除/run/httpd/httpd.pid文件）在打为tar包，重新导入系统</li>
<li>从脚本启动。而不是直接从容器运行服务。在启动服务前，该脚本能够为运行服务进行清理（能删除删除/run/httpd/httpd.pid文件）</li>
</ul>
<p>所以，一般情况不要简单的杀死容器。因为容器退出后，没有进行清理的话，容器会无法使用。当然，docker kill有其他用法。可以向容器发送其他信号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker kill -s SIGHUP centos_web</span><br><span class="line">[mint@ali-mint ~]$ docker kill -s SIGINT centos_web</span><br></pre></td></tr></table></figure>

<p>某些服务可以通过SIGHUP信号，重新加载配置文件，可以不关闭服务更新配置。而SIGINT信号向进程发出一个键盘中断（类如同按下Ctrl+C）。</p>
<h4 id="暂停容器与取消暂停"><a href="#暂停容器与取消暂停" class="headerlink" title="暂停容器与取消暂停"></a>暂停容器与取消暂停</h4><p>使用docker pause命令可以暂停容器内运行的所有进程。也可通过docker unpause取消暂停。本质是使用cgroups的冻结（freeze）特性来暂停和恢复容器进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker pause centos_web</span><br><span class="line">centos_web</span><br><span class="line">[mint@ali-mint ~]$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                  PORTS                    NAMES</span><br><span class="line">a161a77c9763        centos              "python -m SimpleHTT…"   7 minutes ago       Up 5 minutes (Paused)   0.0.0.0:8080-&gt;8080/tcp   centos_web</span><br><span class="line">[mint@ali-mint ~]$ curl localhost:8080</span><br><span class="line">[mint@ali-mint ~]$ docker unpause centos_web</span><br><span class="line">centos_web</span><br><span class="line">[mint@ali-mint ~]$ curl localhost:8080      </span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<p>使用docker ps命令可以看到容器已经被暂停（pause）了，所以centos_web不再对外响应请求。在取消暂停后，再次响应请求。</p>
<h4 id="等待容器的退出代码"><a href="#等待容器的退出代码" class="headerlink" title="等待容器的退出代码"></a>等待容器的退出代码</h4><p>使用docker wait可以确定一个运行的容器，之后等待它退出。当容器退出后，docker wait会自动退出，并打印最初容器的退出代码。要使用它，需要先启动docker wait，确定需要查看退出代码的运行容器。接着，再打开一个shell并停止centos_web。会到docker wait上就显示了退出容器的退出代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker wait centos_web</span><br><span class="line"> </span><br><span class="line">[root@ali-mint ~]$ docker stop centos_web</span><br><span class="line">centos_web</span><br><span class="line"></span><br><span class="line">[mint@ali-mint ~]$ docker wait centos_web</span><br><span class="line">137</span><br></pre></td></tr></table></figure>

<h4 id="重命名容器"><a href="#重命名容器" class="headerlink" title="重命名容器"></a>重命名容器</h4><p>如果不喜欢容器名字。不论正在运行的还是已停止的。都可以使用docker rename命令。并给出需要重命名的容器旧名称已经新名称。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">a161a77c9763        centos              "python -m SimpleHTT…"   25 minutes ago      Up 4 minutes        0.0.0.0:8080-&gt;8080/tcp   centos_web</span><br><span class="line">[mint@ali-mint ~]$ docker rename centos_web centos-web</span><br><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">a161a77c9763        centos              "python -m SimpleHTT…"   25 minutes ago      Up 5 minutes        0.0.0.0:8080-&gt;8080/tcp   centos-web</span><br></pre></td></tr></table></figure>

<p>对比两个docker ps可以发现容器名字centos_web已经变成了centos-web</p>
<h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p>通常使用docker run创建一个运行的容器，通过docker run –rm创建一个运行退出不保存的容器。还可以通过docker create命令创建一个容器而不立即运行。</p>
<p> 使用docker create需要先确定使用的镜像以及要运行的命令。当运行docker create时，将直接保存结果容器，而不是在容器中运行命令。docker create使用与docker run基本一致，但是有例外。如：docker create不能使用–rm，因为docker create执行结果就是容器，主要是保存和待运行容器，如果删除了就事与愿违了。也不需要使用–datach=true (-d)选项。之后启动容器就是以分离模式运行的。如果需要以交互式运行，需要添加-a 和 -i选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker create --name=mybog -it cricket/hangman boggle</span><br><span class="line">f756b6d57097ec88c0d20a5727cb61f23e29d331f1df6ef6b0fd40a27df747fc</span><br><span class="line">[mint@ali-mint ~]$ docker ps -a </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">f756b6d57097        cricket/hangman     "boggle"                 5 seconds ago       Created                                      mybog</span><br><span class="line">[mint@ali-mint ~]$ docker start -ai mybog</span><br><span class="line">+---+---+---+---+   Type '?' for help</span><br><span class="line">| D | C | A | X |</span><br><span class="line">+---+---+---+---+   2:58</span><br><span class="line">| B | B | Y | G |</span><br><span class="line">+---+---+---+---+</span><br><span class="line">| N | U | T | L |</span><br><span class="line">+---+---+---+---+</span><br><span class="line">| A | W | P | D |</span><br><span class="line">+---+---+---+---+</span><br></pre></td></tr></table></figure>

<p>创建一个容器来运行Boggle游戏，并取名为mybog，并使用-it选项指定容器通过伪终端以交互式运行，之后，使用-ai选项连接入标准输入以交互式启动这个容器。</p>
<h3 id="配置容器的存储"><a href="#配置容器的存储" class="headerlink" title="配置容器的存储"></a>配置容器的存储</h3><p>Docker容器镜像是要包含可以重复使用的应用程序。通常会挂载容器外的存储来保存容器数据。使用Docker时，需要注意：</p>
<ul>
<li><strong>管理容器的存储和卷：</strong>为宿主机增加存储空间并不会自动让容器获得更多的存储。然而有很多方D式可以在容器内使用宿主机的存储，挂载到某个容器的存储也可让其他容器使用。</li>
<li><strong>管理宿主机上docker的存储：</strong>Docker自身会使用宿主机的一个存储区域来管理该宿主机的Docker镜像和容器，以及这些镜像和容器的元数据。</li>
</ul>
<h4 id="管理宿主机的存储"><a href="#管理宿主机的存储" class="headerlink" title="管理宿主机的存储"></a>管理宿主机的存储</h4><p>Docker镜像应尽量保持小巧（仅包含所选Linux发行版需要的软件包以及容器内运行的应用程序）。太大不利于下载，即使在本地docker registry中亦是如此。</p>
<p>可以通过挂载外部卷实现数据改变时无需提交镜像变更。再应用程序中采用这种方法，容器镜像不会发生改变。所有状态都会持久化到容外部的存储中。</p>
<h5 id="使用宿主机的卷"><a href="#使用宿主机的卷" class="headerlink" title="使用宿主机的卷"></a>使用宿主机的卷</h5><p>要在运行时将一个卷挂载到容器中，需要为docker run命令使用-v选项。传递-v选项的参数包括：要共享的宿主机目录。紧接着是冒号（:），以及 在容器内的挂载点。示例如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 8080:8080 --name=centos_web -v /tmp/html:/var/www/html centos /usr/sbin/httpd -DFOREGROUND</span><br></pre></td></tr></table></figure>

<p>可以发现，将卷挂载到容器中可能会把宿主机暴露在危险中。应该控制宿主机被挂载的目录权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name=centos_web -v /etc:/var/www/html centos /usr/sbin/httpd -DFOREGROUND</span><br></pre></td></tr></table></figure>

<h5 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h5><p>使用Docker容器的优势之一是一个容器可以查看和使用其他容器中的卷。这种通常被称为数据卷的东西容许将元容器的卷共享给一个或多个容器。可以实现多个容器之间共享持久化存储并为挂载提供一个抽象层。</p>
<p>当挂载一个卷到容器中时，默认挂载的容器具有读写权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -v /tmp/vol:/data --name=datavol -it centos bash</span><br><span class="line">[root@c0702aa7b762 /]#</span><br></pre></td></tr></table></figure>

<p>在运行一个shell,运行新容器并使用–volumes-from=选项指定第一个容器名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run --volumes-from=datavol -d centos touch  /data/mydata</span><br><span class="line">f631015ad203f339ab3e57aa00a0caeec67510485663d23bcfd4fdaa95c5a935</span><br></pre></td></tr></table></figure>

<p>在datavol容器的shell中可以看到已经创建了mydata的新文件，检查宿主机的/tmp/vol/目录，也有新文件mydata</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@c0702aa7b762 /]# ll /data/</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Aug 16 16:39 mydata</span><br><span class="line">[mint@ali-mint ~]$ ll /tmp/vol/</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Aug 17 00:39 mydata</span><br></pre></td></tr></table></figure>

<h5 id="对挂载写保护"><a href="#对挂载写保护" class="headerlink" title="对挂载写保护"></a>对挂载写保护</h5><p>如果需要访问该卷内容，又不让其他容器在该卷写入内容，可以为挂载点添加:ro选项，设置容器为只读挂载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ mkdir /tmp/vol1</span><br><span class="line">[mint@ali-mint ~]$ docker run -v /tmp/vol:/data -v /tmp/vol1/:/data1:ro --name=datavol -it centos bash  </span><br><span class="line">[root@c715ed9a7151 /]# exit</span><br><span class="line">exit</span><br><span class="line">[mint@ali-mint ~]$ docker run --volumes-from=datavol -d centos touch /data1/mydata1 </span><br><span class="line">1b094e337a09e7c2d9b3fedd4841bd93eb470f9c18e295d86af48d995b4847c7</span><br><span class="line">[mint@ali-mint ~]$ ll /tmp/vol1/</span><br><span class="line">total 0</span><br><span class="line">[mint@ali-mint ~]$</span><br></pre></td></tr></table></figure>

<h5 id="挂载设备"><a href="#挂载设备" class="headerlink" title="挂载设备"></a>挂载设备</h5><p>挂载设备是很重要的。Docker服务上运行多个Docker容器，如果能关联一个容器来检查日志文件以确认是否有错误发生，那会非常高效。可以通过挂载系统日志设备（/dev/log）使容器日志在宿主机可见</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -v /dev/log:/dev/log -it centos logger "SYSLOG-TEST This is a test"</span><br><span class="line">[mint@ali-mint ~]$ sudo journalctl -b | grep SYS</span><br><span class="line">Aug 17 01:21:14 ali-mint root[24660]: SYSLOG-TEST This is a test</span><br></pre></td></tr></table></figure>

<p>以上示例通过logger发送消息给systemd journal（通过/dev/log设备）发送日志消息后退出。在宿主机上执行sudo journalctl -b | grep SYS会显示logger命令发送的信息</p>
</div><div class="post-copyright"><blockquote><p>原文作者: Mr.Chen</p><p>原文链接: <a href="http://www.dookt.com/post/6782be63.html">http://www.dookt.com/post/6782be63.html</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/tags/容器/">容器</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/post/a583c2ce.html" class="next">Centos安装vmware虚拟机报错</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Hub-Registry"><span class="toc-text">Docker Hub Registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker镜像和容器"><span class="toc-text">Docker镜像和容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker命令"><span class="toc-text">Docker命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#查找Docker组件信息的命令"><span class="toc-text">查找Docker组件信息的命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#操作正在运行的容器的命令"><span class="toc-text">操作正在运行的容器的命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#操作镜像的命令"><span class="toc-text">操作镜像的命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#操作Docker-Registry的命令"><span class="toc-text">操作Docker Registry的命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#修改现存的镜像的命令"><span class="toc-text">修改现存的镜像的命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#修改容器的状态的命令"><span class="toc-text">修改容器的状态的命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#查看Docker的活动的命令"><span class="toc-text">查看Docker的活动的命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#创建镜像和容器的命令"><span class="toc-text">创建镜像和容器的命令</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#部署搭建Docker运行环境"><span class="toc-text">部署搭建Docker运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在Centos7系统中安装docker"><span class="toc-text">在Centos7系统中安装docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在ubuntu系统安装docker"><span class="toc-text">在ubuntu系统安装docker</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#搭建Docker-Registry"><span class="toc-text">搭建Docker Registry</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装docker-registry"><span class="toc-text">安装docker-registry</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用yum安装"><span class="toc-text">使用yum安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用docker容器部署"><span class="toc-text">使用docker容器部署</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取镜像"><span class="toc-text">获取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#允许访问registry"><span class="toc-text">允许访问registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为镜像打个标签"><span class="toc-text">为镜像打个标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#推送镜像"><span class="toc-text">推送镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拉取镜像"><span class="toc-text">拉取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置私有Docker-Registry仓库"><span class="toc-text">配置私有Docker Registry仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行容器镜像"><span class="toc-text">运行容器镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#以交互式运行容器镜像"><span class="toc-text">以交互式运行容器镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在容器内运行管理命令"><span class="toc-text">在容器内运行管理命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行容器化服务"><span class="toc-text">运行容器化服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在容器中运行服务时进行资源限制"><span class="toc-text">在容器中运行服务时进行资源限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行特权容器"><span class="toc-text">运行特权容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找、拉取、保存和装载容器镜像"><span class="toc-text">查找、拉取、保存和装载容器镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#搜索镜像"><span class="toc-text">搜索镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在Docker-Hub上检索镜像"><span class="toc-text">在Docker Hub上检索镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从Docker-Registry上拉取镜像"><span class="toc-text">从Docker Registry上拉取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#保存和装载镜像"><span class="toc-text">保存和装载镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为镜像做标签"><span class="toc-text">为镜像做标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检视容器"><span class="toc-text">检视容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用docker-inspect检视基础镜像"><span class="toc-text">用docker inspect检视基础镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看镜像历史"><span class="toc-text">查看镜像历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检视正在运行的容器"><span class="toc-text">检视正在运行的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#启动要检视的容器"><span class="toc-text">启动要检视的容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检视整个容器配置"><span class="toc-text">检视整个容器配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检视单个容器的属性"><span class="toc-text">检视单个容器的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检视运行终端会话的容器"><span class="toc-text">检视运行终端会话的容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检视容器的内存和CPU限制"><span class="toc-text">检视容器的内存和CPU限制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寻找探查容器的其他方法"><span class="toc-text">寻找探查容器的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用docker-top查看进程"><span class="toc-text">使用docker top查看进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用docker-attach与容器内服务进行交互"><span class="toc-text">使用docker attach与容器内服务进行交互</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用docker-exec在正在运行的容器中启动新进程"><span class="toc-text">使用docker exec在正在运行的容器中启动新进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用docker-logs查看容器进程的输出"><span class="toc-text">使用docker logs查看容器进程的输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用docker-diff查看容器的变化"><span class="toc-text">使用docker diff查看容器的变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用docker-cp从容器复制文件"><span class="toc-text">使用docker  cp从容器复制文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器的启动、停止和重启"><span class="toc-text">容器的启动、停止和重启</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#停止和启动容器"><span class="toc-text">停止和启动容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#启动和停止分离式容器"><span class="toc-text">启动和停止分离式容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#启动和停止交互式容器"><span class="toc-text">启动和停止交互式容器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重启容器"><span class="toc-text">重启容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向容器发送信号"><span class="toc-text">向容器发送信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#暂停容器与取消暂停"><span class="toc-text">暂停容器与取消暂停</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待容器的退出代码"><span class="toc-text">等待容器的退出代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重命名容器"><span class="toc-text">重命名容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建容器"><span class="toc-text">创建容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置容器的存储"><span class="toc-text">配置容器的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#管理宿主机的存储"><span class="toc-text">管理宿主机的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用宿主机的卷"><span class="toc-text">使用宿主机的卷</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据卷容器"><span class="toc-text">数据卷容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对挂载写保护"><span class="toc-text">对挂载写保护</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#挂载设备"><span class="toc-text">挂载设备</span></a></li></ol></li></ol></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/post/6782be63.html">Docker入门</a></li><li class="post-list-item"><a class="post-list-link" href="/post/a583c2ce.html">Centos安装vmware虚拟机报错</a></li><li class="post-list-item"><a class="post-list-link" href="/post/b2e09379.html">k8s平台搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/post/c6b0c30c.html">Nginx设置为系统服务</a></li><li class="post-list-item"><a class="post-list-link" href="/post/a2c1797d.html">Tomcat设置为系统服务</a></li><li class="post-list-item"><a class="post-list-link" href="/post/7df7e5a.html">Python编写zabbix告警邮件</a></li><li class="post-list-item"><a class="post-list-link" href="/post/4120479c.html">DockerFile生成镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/post/d936a15c.html">Jenkins发布脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/post/d6261197.html">k8s-一个简单的例子</a></li><li class="post-list-item"><a class="post-list-link" href="/post/41380.html">Mysql设置权限</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jenkins/">Jenkins</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/K8S/">K8S</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/FTP/" style="font-size: 15px;">FTP</a> <a href="/tags/系统管理/" style="font-size: 15px;">系统管理</a> <a href="/tags/高可用/" style="font-size: 15px;">高可用</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/Scripts/" style="font-size: 15px;">Scripts</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/虚拟化/" style="font-size: 15px;">虚拟化</a> <a href="/tags/Python基础/" style="font-size: 15px;">Python基础</a> <a href="/tags/Zabbix/" style="font-size: 15px;">Zabbix</a> <a href="/tags/监控/" style="font-size: 15px;">监控</a> <a href="/tags/磁盘管理/" style="font-size: 15px;">磁盘管理</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/运维基本功/" style="font-size: 15px;">运维基本功</a> <a href="/tags/系统命令/" style="font-size: 15px;">系统命令</a> <a href="/tags/容器/" style="font-size: 15px;">容器</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Mr.Chen.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?c6588ff9864e03b5fbcbba5a323ad966";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>